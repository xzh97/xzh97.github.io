<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追梦的蚂蚁</title>
  
  <subtitle>何须仰望他人，自己亦是风景</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xzh97.github.io/"/>
  <updated>2020-12-03T08:52:24.215Z</updated>
  <id>https://xzh97.github.io/</id>
  
  <author>
    <name>xzh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Webpack】项目优化</title>
    <link href="https://xzh97.github.io/2020/12/03/learn-webpack-optimization/"/>
    <id>https://xzh97.github.io/2020/12/03/learn-webpack-optimization/</id>
    <published>2020-12-03T08:52:46.000Z</published>
    <updated>2020-12-03T08:52:24.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>今天我们来学习如何用webpack来优化项目。</p><h2 id="优化方式"><a class="header-anchor" href="#优化方式"></a>优化方式</h2><h3 id="优化无用的css"><a class="header-anchor" href="#优化无用的css"></a>优化无用的css</h3><p>顾名思义，就是把没有用到的css样式优化掉，可以减少构建包的大小</p><p>主要是通过插件<code>purgecss-webpack-plugin</code>来实现。</p><p><a href="https://www.purgecss.cn/guides/vue.html#use-the-vue-cli-plugin" target="_blank" rel="noopener">vue-cli3使用PurgecssWebpackPlugin</a>（这里想弄个栗子的，但是这个<code>vue-cli-plugin-purgecss</code>的插件一直装不上只能作罢）</p><p><a href="https://www.purgecss.cn/plugins/webpack.html#%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">webpack使用PurgecssWebpackPlugin</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常方式使用</span></span><br><span class="line"><span class="keyword">const</span> PATHS = &#123;</span><br><span class="line">  src: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> PurgecssWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">// 可以直接这样用</span></span><br><span class="line">            paths: glob.sync(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>, &#123;<span class="attr">nodir</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">            <span class="comment">// 也可以用globAll来选择具体使用的目录</span></span><br><span class="line">            paths: globAll.sync([</span><br><span class="line">                <span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/index.html`</span>,</span><br><span class="line">                <span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/styles/*`</span>,</span><br><span class="line">                <span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/*/*.vue`</span>,</span><br><span class="line">            ]),</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提取CSS到单独的文件里"><a class="header-anchor" href="#提取CSS到单独的文件里"></a>提取CSS到单独的文件里</h3><p>为什么要提取css到单独的文件中呢？项目比较大时，样式会特别多且特别复杂。如果仍然用<code>'style-loader', 'css-loader',  'sass-loader'</code>这种方式的话会大幅延长首页加载时间，且很多样式并不需要在首页加载。所以我们需要对CSS做优化且优化点就在于分离不同模块的样式且最好分离出的模块能够按需加载。</p><p>这里就需要用到一个插件来对这种现象进行优化：webpack4的话使用<code>mini-css-extract-plugin</code>，webpack3的话使用<code>extract-text-webpack-plugin</code>。<br>这两个插件的作用是一样的，但是前者功能更加完善（毕竟是后面出的，肯定优化更好一些）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PATHS = &#123;</span><br><span class="line">  src: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="comment">// MiniCssExtractPlugin插件支持css按需加载和sourceMap</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: isDev ? [name].css : [name].[contentHash].css,</span><br><span class="line">            chunkFilename: isDev ? [id].css : [id].[contentHash].css</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    modules:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a class="header-anchor" href="#自动添加前缀"></a>自动添加前缀</h3><p>由于样式可能会存在浏览器兼容问题，所以我们会需要在样式中添加前缀，但是你也不可能所有的样式都写一边。这里我们可以使用<code>postcss</code>来做这件事情，那么在webpack中我们就需要用到<code>postcss-loader</code>和<code>autoprefixer</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="comment">// MiniCssExtractPlugin插件支持按需加载和sourceMap</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: [name].[contentHash].css,</span><br><span class="line">            chunkFilename: [id].[contentHash].css</span><br><span class="line">        &#125;),</span><br><span class="line">        autoPrefixer(&#123;</span><br><span class="line">            browser: [</span><br><span class="line">                <span class="string">'last 10 Chrome versions'</span>,</span><br><span class="line">                <span class="string">'last 5 Firefox versions'</span>,</span><br><span class="line">                <span class="string">'Safari &gt;= 6'</span>, </span><br><span class="line">                <span class="string">'ie&gt; 8'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    modules:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>,  <span class="string">'sass-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩文件"><a class="header-anchor" href="#压缩文件"></a>压缩文件</h3><p>首先，webpack4中默认在<code>production</code>时会开启压缩。但是这个压缩是对js文件的压缩，所以css文件我们需要通过<code>optimize-css-assets-webpack-plugin</code>来完成。But，由于配置css压缩时会覆盖掉webpack的默认压缩配置， 所以需要额外引入js压缩插件<code>terser-webpack-plugin</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        minimize: <span class="literal">true</span>,</span><br><span class="line">        minimizer:&#123;</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                parallel: <span class="number">4</span>, <span class="comment">// 并行压缩</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS抽取公共代码"><a class="header-anchor" href="#JS抽取公共代码"></a>JS抽取公共代码</h3><p>很多时候，一些公共的代码/库会在应用内各个模块内都用到。但是按照之前的逻辑，webpack打包的时候会把这些代码多次打入进去。这样就会使得构建包的体积增大。所以，我们需要能够把公共代码提取出来，这样子只需要加载一次，其它地方用的时候都要不需要重复加载。</p><p>这里我们主要使用的是<code>splitChunkPlugin</code>来抽取公共代码，不过这个插件不需要我们显式的引入使用，在webpack4中可以通过<code>optimization.splitChunks</code>来配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack官网给的默认配置。</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'async'</span>,</span><br><span class="line">            minSize: <span class="number">30000</span>,</span><br><span class="line">            maxSize: <span class="number">0</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">            maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">            automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">            name: <span class="literal">true</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendors: &#123;</span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                    priority: <span class="number">-10</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    minChunks: <span class="number">2</span>,</span><br><span class="line">                    priority: <span class="number">-20</span>,</span><br><span class="line">                    reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="chunks"><a class="header-anchor" href="#chunks"></a>chunks</h4><p>chunks内有<code>['all', 'async', 'initial']</code>三种模式， 默认为<code>async</code>。</p><ul><li>async：只从异步加载的模块里进行拆分</li><li>initial：只从入口模块进行拆分</li><li>all：既从异步加载的模块里进行拆分也从入口模块进行拆分</li></ul><h3 id="配置多入口"><a class="header-anchor" href="#配置多入口"></a>配置多入口</h3><p>多入口其实本质上也是一种分离代码的方式。也是减少初始化需要加载的内容数量。然后是利用<code>webpack.config.entry</code>来配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="comment">// 两个入口 main，other</span></span><br><span class="line">    entry:&#123;</span><br><span class="line">        main: <span class="string">'main.js'</span>,</span><br><span class="line">        other: <span class="string">'other.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 只需要这样子写就可以了。 输出的也是main，other</span></span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="noParse"><a class="header-anchor" href="#noParse"></a>noParse</h3><p>对于一些引用到的第三方库，我们可以很清晰知道它不会和其它模块产生依赖时。就可以用到<code>noParse</code>。它的作用就是让webpack不去解析这些库的依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        noParse: <span class="regexp">/jquery|bootstrap/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IgnorePlugin"><a class="header-anchor" href="#IgnorePlugin"></a>IgnorePlugin</h3><p>对于引用的一些第三方库，例如<code>momentjs，dayjs</code>。他们内部都是自带国际化处理的，那么就会有很多对应的语言包。但是很多时候我们往往不需要这些语言包。这个时候我们就可以通过使用<code>IgnorePlugin</code>来忽略掉所有的语言包，当然，在这之后我们还得按需引入实际要用到的语言包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="comment">// 设置为中文</span></span><br><span class="line">moment.locale(<span class="string">'zh-CN'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这之前我们得通过阅读源码找到moment的语言包目录。这里不细讲了。</span></span><br><span class="line"><span class="comment">// 最后可以找到moment的语言包目录是 /locale</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="comment">// ...其它插件</span></span><br><span class="line">        <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/\.\/locale/</span>, /moment/)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="comment">// 需要手动引入该语言包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span>;</span><br><span class="line"><span class="comment">// 设置为中文</span></span><br><span class="line">moment.locale(<span class="string">'zh-CN'</span>);</span><br></pre></td></tr></table></figure><h3 id="DLL预编译优化"><a class="header-anchor" href="#DLL预编译优化"></a>DLL预编译优化</h3><p>对于一些不会经常更新的库，例如<code>vue，react</code>等等。这些库我们一般不会更新版本，但是每次打包时都要解析。这样是会影响到webpack的打包速度的。而且就算我们做了拆分，提升的也只是在页面中访问的速度，而不是webpack打包的速度。所以为了提高webpack构建的速度，我们可以采用类似于dll（动态链接库）的方式来提升构建速度。</p><p>这样子做的本质其实就是相当于我提前把这一部分不会经常更新的库先打包一遍，这样子我之后webpack打包就只需要打包另外一部分内容。相当于减少了打包的工作量。</p><p>DLL优化中我们主要会用到两个插件，一个是<code>DLLPlugin</code>，一个是<code>DLLReferencePlugin</code>。<br><code>DLLPlugin</code>呢主要是用来生成dll内容的。dll内容包括打包生成的<code>js</code>文件以及<code>manifest.json</code>（<code>DLLReferencePlugin</code>会使用该json文件来做映射依赖性，同时webpack通过这个文件可以知道哪些文件已经提取打包好了）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dll.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'none'</span>,</span><br><span class="line">    entry:&#123;</span><br><span class="line">        vue: [</span><br><span class="line">            <span class="string">'vue/dist/vue'</span>,</span><br><span class="line">            <span class="string">'vue-router'</span>,</span><br><span class="line">            <span class="string">'vuex'</span>,</span><br><span class="line">            <span class="string">'axios'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./public/static/dll'</span>),</span><br><span class="line">        filename: <span class="string">'[name]_[hash].dll.js'</span>,</span><br><span class="line">        library: <span class="string">'[name]_[hash]'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">'./public/static/dll'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">            context: __dirname</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// 引入之前生成的manifest.json</span></span><br><span class="line"><span class="keyword">const</span> dllJson = <span class="built_in">require</span>(<span class="string">'./public/static/dll/vue-manifest.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="comment">// ... 其它插件</span></span><br><span class="line">        <span class="comment">// 这里只是成功的引入了dll依赖关系，并没有动态的把它导入到项目里。</span></span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">            manifest: dllJson,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'index.html'</span>,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 导入dll到html中方案1</span></span><br><span class="line">            vendor: <span class="string">'/static/dll/'</span> + dllJson.name + <span class="string">'.dll.js'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 导入dll到html中方案2</span></span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath: path.resolve(__dirname, <span class="string">`../dist/static/dll/<span class="subst">$&#123;dllJson.name&#125;</span>_dll.js`</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导入dll到html中方案1</span></span><br><span class="line"><span class="comment">// index.html 注入dll.js </span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id='app'&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="&lt;%= htmlWebpackPlugin.options.vendor %&gt;"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="TreeShaking"><a class="header-anchor" href="#TreeShaking"></a>TreeShaking</h3><p><code>TreeShaking</code>的意思就是删除没有用到的冗余代码，可以理解为一个提纯操作。把使用到的代码提取出来然后在打包。可以通过<code>package.json</code>中的<code>sideEffects</code>属性或者是<code>webpack.config.module.rules</code>来设置。</p><p><code>sideEffects</code>有三个值：</p><ul><li>true： 不做tree-shaking</li><li>false： 都可以做tree-shaing</li><li>[]：对不符合数组内结果的内容做tree-shaking</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不符合该匹配结果的都会做tree-shaking</span></span><br><span class="line"><span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"./src/some-side-effectful-file.js"</span>,</span><br><span class="line">    <span class="string">"*.css"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                include: path.resolve(<span class="string">"node_modules"</span>, <span class="string">"lodash"</span>),</span><br><span class="line">                <span class="comment">// 做tree-shaking</span></span><br><span class="line">                sideEffects: <span class="literal">false</span>, </span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                include: path.resolve(<span class="string">"src/view/home/index.vue"</span>),</span><br><span class="line">                <span class="comment">// 不做tree-shaking</span></span><br><span class="line">                sideEffects: <span class="literal">true</span>, </span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中还有，为了更好的tree-shaking。我们在平时coding的时候，可以这样子做：</p><ul><li><code>import {cloneDeep} from 'lodash'</code> 代替 <code>import _ from 'lodash'</code></li><li><code>import cloneDeep from 'lodash/cloneDeep'</code> 代替 <code>import _ from 'lodash'</code></li><li>像项目里常用的的方法库这种，尽量这样子写也有助于tree-shaking  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const foo()&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">export const foo1()&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">    foo,</span><br><span class="line">    foo1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多进程优化构建"><a class="header-anchor" href="#多进程优化构建"></a>多进程优化构建</h3><p>首先，由于js本身是一个单线程的语言，所以webpack打包的时候，任务只能一个一个的完成。但是我们又想要webpack能够同时完成多个任务。那怎么办呢？</p><p>我们可以通过<code>HappyPack，thread-loader（官方推荐）</code>等插件来使得webpack能够做到多线操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV === <span class="string">'development'</span>;</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="keyword">const</span> HappyThreadPool = HappyPack.ThreadPool(&#123;<span class="attr">size</span>: os.cpus().length&#125;);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_mudoles/</span>,</span><br><span class="line">                use: <span class="string">'happypack/loader?id=happyBabel'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: <span class="string">'happypack/loader?id=happyScss'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">'happyBabel'</span>, <span class="comment">// loaders声明的对应的id</span></span><br><span class="line">            threads: <span class="number">4</span>, <span class="comment">// 线程数</span></span><br><span class="line">            loaders:[<span class="string">'babel-loader'</span>] <span class="comment">// loaders</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">            id: <span class="string">'happyScss'</span>,</span><br><span class="line">            threads: <span class="number">2</span>, </span><br><span class="line">            loaders:[isDev ? <span class="string">'style-loader'</span> : MinicssExtractPlugin.loader,<span class="string">'css-loader'</span>,<span class="string">'sass-loader'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：由于happyPack作者自身原因（对于js逐渐缺少兴趣），happypack现在已经停止维护。webpack4及以后官方都推荐使用thread-loader。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV === <span class="string">'development'</span>;</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_mudoles/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'thread-loader'</span>,</span><br><span class="line">                        options:&#123;</span><br><span class="line">                            workers: <span class="number">2</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'thread-loader'</span>,</span><br><span class="line">                        options:&#123;</span><br><span class="line">                            workers: <span class="number">2</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    isDev ? <span class="string">'style-loader'</span> : MinicssExtractPlugin.loader,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    <span class="string">'sass-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另注：由于进程启动大概需要600ms，且进程的通信也是有开销的。所以需要做一个取舍。如果项目比较小的话，多进程可以不开。</strong></p><h2 id="相关文章"><a class="header-anchor" href="#相关文章"></a>相关文章</h2><p><a href="https://xzh97.github.io/2020/11/20/learn-webpack/">【Webpack】基础配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;今天我们来学习如何用webpack来优化项目。&lt;/p&gt;
&lt;h2 id=&quot;优化方式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#优化方
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://xzh97.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>【Webpack】基础配置</title>
    <link href="https://xzh97.github.io/2020/11/20/learn-webpack/"/>
    <id>https://xzh97.github.io/2020/11/20/learn-webpack/</id>
    <published>2020-11-20T03:51:23.000Z</published>
    <updated>2020-11-30T07:51:11.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>馋<code>webpack</code>已经很久了，今天就来学学吧。😜。</p><p>（第一版其实是2月份的文章了，但是最近这个月决定重新学webpack，所以决定把日期改成最近的时间）</p><h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><p>Webpack是一个前端资源加载/打包工具，也是前端工程化的体现。</p><h2 id="Webpack基础配置"><a class="header-anchor" href="#Webpack基础配置"></a>Webpack基础配置</h2><h3 id="mode"><a class="header-anchor" href="#mode"></a>mode</h3><p><code>mode</code>用来告知<code>webpack</code>需要采用对应模式的内置优化。可以在<code>webpack.config.js</code>里设置，也可以在<code>npm</code>命令里添加 <code>--mode</code>参数来设置。有以下两种：</p><ul><li>development  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.development.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">mode: &#39;development&#39;</span><br><span class="line">plugins: [</span><br><span class="line">    new webpack.NamedModulesPlugin(),</span><br><span class="line">    new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>production  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.production.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">mode: &#39;production&#39;,</span><br><span class="line">plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#x2F;* ... *&#x2F;),</span><br><span class="line">    new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) &#125;),</span><br><span class="line">    new webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">    new webpack.NoEmitOnErrorsPlugin()</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>设置mode时同时会把 process.env.NODE_ENV设置为当前环境的值</strong></p><h4 id="entry"><a class="header-anchor" href="#entry"></a>entry</h4><p><code>entry</code>其实就是指定<code>webpack</code>读取项目的起始点，配置方式有以下这些：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="comment">// 单入口</span></span><br><span class="line">    entry: <span class="string">'./entry1'</span>,</span><br><span class="line">    <span class="comment">//多入口</span></span><br><span class="line">    entry: [</span><br><span class="line">        <span class="string">'./entry1'</span>,</span><br><span class="line">        <span class="string">'./entry2'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 多入口时</span></span><br><span class="line">    entry:&#123;</span><br><span class="line">        a: <span class="string">'./entry1'</span>,</span><br><span class="line">        <span class="comment">//若b有多个入口</span></span><br><span class="line">        b: [<span class="string">'./entry2-a'</span>, <span class="string">'./entry2-b'</span>,],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loader"><a class="header-anchor" href="#loader"></a>loader</h3><p>首先，<code>webpack</code>本身的打包只是对js文件的打包，那么非js文件怎么打包进来呢？这个时候<code>loader</code>的作用就体现出来了。<code>loader</code>就是一个转译器，<strong>它可以把非js文件进行处理，然后使得非js文件可以进入构建包内。</strong></p><p><a href="https://www.webpackjs.com/api/loaders/" target="_blank" rel="noopener">想了解更多的loader信息可点击此处</a></p><p>那么如何使用<code>loader</code>呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>, </span><br><span class="line">                <span class="comment">// 1. loader不需要做其它配置时</span></span><br><span class="line">                use: <span class="string">'css-loader'</span>,</span><br><span class="line">                <span class="comment">// 2. loader需要传入参数配置</span></span><br><span class="line">                use: [</span><br><span class="line">                    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        modules: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还可以在<code>cli</code>命令里加入以下<code>--module bind 'css=style-loader!css-loader'</code>以及在源码中直接导入 <code>loader</code>的东西，但是这两种方式都不太好，容易导致意外的错误且不易调试。</p><p>所以还是推荐写在<code>modules.rules</code>。</p><p>这里就简单列举一些常用的loader</p><ul><li><code>css-loader</code>: 解析<code>css</code>文件</li><li><code>style-loader</code>: 把解析好的<code>css</code>用<code>style</code>标签显示出来</li><li><code>babel-loader</code>: 把<code>es6</code>及之后的语法解析成<code>es5</code>语法，最大的作用就是兼容浏览器。</li><li><code>url-loader</code>,<code>file-loader</code>: <code>webpack</code>加载图片, <code>url-loader</code>更像是<code>file-loader</code>的增强版。当设置<code>limit</code>时，超出此范围则用<code>file-loader</code>解析，小于则返回<code>base64</code>格式。</li><li><code>raw-loader</code>: 读取文件内的内容，并作为字符串返回</li><li><code>sass-loader</code>,<code>less-loader</code>: css预编译文件解析。</li><li><code>vue-loader</code>: 解析<code>.vue</code>文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    modules：&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use:[<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'scss-loader'</span>]</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用多个loader时是有顺序的，顺序是从右到左。但实际调用过程上如下所示</span></span><br><span class="line"><span class="comment">// pitch方法意为跳过</span></span><br><span class="line">|- a-loader <span class="string">`pitch`</span></span><br><span class="line">  |- b-loader <span class="string">`pitch`</span></span><br><span class="line">    |- c-loader <span class="string">`pitch`</span></span><br><span class="line">      |- requested <span class="built_in">module</span> is picked up <span class="keyword">as</span> a dependency</span><br><span class="line">    |- c-loader normal execution</span><br><span class="line">  |- b-loader normal execution</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure><h3 id="plugins"><a class="header-anchor" href="#plugins"></a>plugins</h3><p>首先，<code>plugin</code>的机制来说我个人觉得和浏览器内的交互事件其实比较类似。因为<code>webpack</code>在运行周期时同样会有很多的事件，所以<code>plugins</code>的作用可以类比于我们在浏览器中对元素的事件监听处理。其实就是我们调用<code>webpack</code>的底层<code>api</code>来编写具体功能的实现。它可以是一个构建时的处理，也可以是对输出结果的优化（其实就是打包优化），还可以对引入资源进行管理。从这里来看，<code>plugins</code>的功能范围对比起<code>loader</code>来说是更加广泛的。</p><p><a href="https://www.webpackjs.com/api/plugins/" target="_blank" rel="noopener">想了解更多的plugins信息可点击此处</a></p><p>那么如何使用<code>plugins</code>呢？ 其实只需要在<code>webpack.config.js</code>里的<code>plugins</code>参数里设置就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="comment">// 引入插件然后在这里传入插件的实例化对象，</span></span><br><span class="line">        <span class="comment">// new plugin(&#123;//插件参数...&#125;)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 举个具体的栗子：</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./index.html'</span>,</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下列举一些常用的插件：</p><ul><li><code>mini-css-extract-plugin</code> &amp; <code>extract-text-webpack-plugin</code><ul><li>作用：抽离<code>css</code>到单独的文件中并以<code>link</code>引入到<code>html</code>中使用。</li><li>使用：<code>webpack &gt;= 4.0 ? mini-css-extract-plugin : extract-text-webpack-plugin</code></li></ul></li><li><code>html-webpack-plugin</code>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./index.html'</span>, <span class="comment">// 模板html,</span></span><br><span class="line">        filename: <span class="string">'index.html'</span>, <span class="comment">// 目标html</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><code>mini-css-extract-plugin</code><ul><li>打包的时候提取<code>css</code>到单独的文件，并且支持按需加载和<code>sourceMap</code></li></ul></li><li><code>progress-bar-webpack-plugin</code><ul><li><code>vue-cli 3</code>打包的时候无法显示出打包所花费的时间，加这个可以显示出来</li></ul></li><li><code>purge-css-webpack-plugin</code><ul><li>删除未使用的<code>css</code></li></ul></li><li><code>DLLPlugin和DLLReferencePlugin</code><ul><li><code>DLLPlugin</code>主要作用是把一些不经常变化的第三方库单独打包出来，然后会生成一个<code>manifest.json</code>，然后通过<code>DLLReferencePlugin</code>去引用。可以提升构建速度</li></ul></li><li><code>add-asset-html-webpack-plugin</code><ul><li>页面打包后，插入我们特定<code>script</code>的引用，来达到全局变量的效果（暴露在<code>Window</code>下）</li></ul></li><li><code>commons-chunk-plugin</code>&amp;<code>split-chunk-plugin</code><ul><li>两者主要是用来提取第三方库和公共模块代码，避免首屏加载的bundle文件或者按需加载的bundle文件体积过大，从而导致加载时间过长。</li><li>后者是前者的升级版，解决了前者在提取公共代码的重复问题。且webpack4中已经删除了<code>commons-chunk-plugin</code>改用了<code>split-chunk-plugin</code>。</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; commons和split的对比</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; commons-chunk-plugin</span><br><span class="line">chunk-a: react, react-dom, a-comp</span><br><span class="line">chunk-b: react, react-dom, b-comp</span><br><span class="line">&#x2F;&#x2F; 会出现重复代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; split-chunk-plugin</span><br><span class="line">chunk-a ~ chunk-b : react, react-dom,</span><br><span class="line">chunk-a: a-comp</span><br><span class="line">chunk-b: b-comp</span><br><span class="line">&#x2F;&#x2F; 不会出现重复代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="resolve"><a class="header-anchor" href="#resolve"></a>resolve</h3><p><code>resolve</code>的作用是设置模块怎么被解析，数据结构是<code>Object</code>。接下来列举一些比较常用的属性。</p><h4 id="alias"><a class="header-anchor" href="#alias"></a>alias</h4><p><code>alias</code>作用是设置别名，可以使得引入模块变得更加简单。举个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        alias:&#123;</span><br><span class="line">            <span class="comment">// path.resolve来确定引入路径不会出问题</span></span><br><span class="line">            <span class="string">"@"</span>: path.resolve(__dirname, <span class="string">'./src'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块时</span></span><br><span class="line"><span class="keyword">import</span> HomeView <span class="keyword">from</span> <span class="string">'@/views/home/index.vue'</span>;</span><br></pre></td></tr></table></figure><h4 id="extensions"><a class="header-anchor" href="#extensions"></a>extensions</h4><p><code>extensions</code>作用是自动扩展，可以自动解析确定的扩展。举个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        <span class="comment">// 默认选项是.js .json</span></span><br><span class="line">        extensions: [<span class="string">'.js'</span>, <span class="string">'json'</span>, <span class="string">'.vue'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块时可以不指定扩展（也就是文件后缀名）</span></span><br><span class="line"><span class="keyword">import</span> HomeView <span class="keyword">from</span> <span class="string">'@/views/home/index'</span>;</span><br></pre></td></tr></table></figure><h4 id="modules"><a class="header-anchor" href="#modules"></a>modules</h4><p><code>modules</code>作用是告诉webpack解析时应该搜索的目录。举个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        <span class="comment">// 意思是webpack搜索目录优先找src目录下的，没有再从node_modules找</span></span><br><span class="line">        modules: [path.resolve(__dirname, <span class="string">'./src/'</span>), <span class="string">'node_modules'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时也可以不写前面的 '@/'，和alias有异曲同工之妙</span></span><br><span class="line"><span class="keyword">import</span> HomeView <span class="keyword">from</span> <span class="string">'views/home/index.vue'</span>;</span><br></pre></td></tr></table></figure><h3 id="devServer"><a class="header-anchor" href="#devServer"></a>devServer</h3><p><code>devServer</code>是开发中用来启动本地服务，方便开发。下面举个栗子来说明各属性作用😂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">false</span>, <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line">        port: <span class="number">8080</span>, <span class="comment">// 本地服务启用端口</span></span><br><span class="line">        <span class="comment">// webpack中有一个hotModuleReplacementPlugin, hot选项其实就可以当作是否启用了这个插件。</span></span><br><span class="line">        hot: <span class="literal">true</span>, <span class="comment">// 是否启用热更新</span></span><br><span class="line">        compress: <span class="literal">true</span>, <span class="comment">// 是否启用gzip压缩</span></span><br><span class="line">        https: <span class="literal">true</span>, <span class="comment">// 是否启用https</span></span><br><span class="line">        <span class="comment">// 是否开启代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'localhost:3000/'</span>, <span class="comment">// 对应自己的后端接口</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>, <span class="comment">// 请求头中显示target</span></span><br><span class="line">                ws: <span class="literal">true</span>, <span class="comment">// 是否代理websocket</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                  <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 是否指定静态文件目录，</span></span><br><span class="line">        contentBase: path.join(__dirname, <span class="string">"public"</span>), </span><br><span class="line">        publicPath: <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="externals"><a class="header-anchor" href="#externals"></a>externals</h3><p>按照<code>webpack</code>官网里的解释，如果我们想引用一个库，但是又不想把<code>webpack</code>把它打进包里且我们希望可以正常引用这个库。这个时候就可以使用<code>externals</code>配置。例如官网中的栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script</span><br><span class="line">  src=<span class="string">"https://code.jquery.com/jquery-3.1.0.js"</span></span><br><span class="line">  integrity=<span class="string">"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="</span></span><br><span class="line">  crossorigin=<span class="string">"anonymous"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/webpack.config.js</span></span><br><span class="line"><span class="regexp">const config = &#123;</span></span><br><span class="line"><span class="regexp">    externals: &#123;</span></span><br><span class="line"><span class="regexp">        jquery: jQuery</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 引用</span></span><br><span class="line"><span class="regexp">import $ from 'jquery';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">$('.my-element').animate(...);</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>其实看了这些配置，基础的webpack配置已经没有啥大问题了。还有一些比较小的点就没写了，之后有疑问也可以去<a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">webpack中文网</a>查看对应部分配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;馋&lt;code&gt;webpack&lt;/code&gt;已经很久了，今天就来学学吧。😜。&lt;/p&gt;
&lt;p&gt;（第一版其实是2月份的文章了，但是最近这个月决定重新学webp
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://xzh97.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>信息安全学习</title>
    <link href="https://xzh97.github.io/2020/08/23/information-safe/"/>
    <id>https://xzh97.github.io/2020/08/23/information-safe/</id>
    <published>2020-08-23T09:59:27.000Z</published>
    <updated>2020-09-07T05:07:30.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>昨天我们团队的<strong>安全大佬</strong>给我们开展了一个安全培训，怕自己之后很容易会忘掉。所以写篇文章来记录一些常见的安全问题以及应对策略。同时也方便自己随时阅读，加深对于信息安全的理解</p><h2 id="常见的安全问题"><a class="header-anchor" href="#常见的安全问题"></a>常见的安全问题</h2><h3 id="sql-Injection（sql注入）"><a class="header-anchor" href="#sql-Injection（sql注入）"></a>sql Injection（sql注入）</h3><p>sql注入的<strong>核心原理</strong>是因为没有对用户输入的内容做<strong>验证</strong>和<strong>净化</strong>处理。攻击者在输入的内容里构造恶意sql语句然后提交给服务端执行（好难举例，我在我自己的项目里没构造出来）</p><h4 id="减轻或者弱化sql注入的方式："><a class="header-anchor" href="#减轻或者弱化sql注入的方式："></a>减轻或者弱化sql注入的方式：</h4><ul><li>对用户提交的数据进行内容转义/内容验证</li><li>白名单机制</li><li>使用预编译语句，参数化查询的方式（这里我之前写博客后端服务的时候，有看别人这么写但不是很清楚其中缘由。这次有点恍然大明白的感jio）</li><li>从策略上来说，最直接有效的方式就是<strong>充钱</strong>买支持防御注入攻击的WAF（应用程序防火墙），你懂的，<strong>充钱能使你更强</strong></li></ul><p>其中呢，前端能做的就是对输入的数据做一些校验（其实也没啥太大用处，因为用户的输入是随心所欲的，总会有漏洞可以绕过验证）。<strong>根源上的解决方法还得是预编译语句和参数化的查询</strong>，它的大体过程是sql服务器先执行sql存到缓存池里，然后把输入的数据当作<strong>参数变量</strong>传进来。而sql服务器不会把参数变量里的值当成sql语句的一部分，从而防止注入。</p><h3 id="Broken-Authentication（中断身份认证）"><a class="header-anchor" href="#Broken-Authentication（中断身份认证）"></a>Broken Authentication（中断身份认证）</h3><h4 id="常见问题："><a class="header-anchor" href="#常见问题："></a>常见问题：</h4><ul><li>弱口令<ul><li>口令长度是否大于8</li><li>口令是否包含特殊字符，大写字母，小写字母，数字的三类</li></ul></li><li>密码泄露</li><li>密码爆破</li><li>明文密码<br><img src="http://qfi1chz6p.hn-bkt.clouddn.com/broken_authentication.png" alt="image"></li></ul><p>解释一下Session覆盖。session或cookie的覆盖(它被用作修改指定用户的密码,可能就是用户名),而服务器端只是简单判断了一下修改链接的key是否存在就可以修改密码了,而没有判断key是否对应指定用户名。举个例子：先向自己邮箱A发一封找回密码，再向用户B的邮箱发一封，当前浏览器记录用户B的账户信息，然后去自己的邮箱A点击找回密码链接，读取了存在浏览器用户B的账户信息，成功修改了密码</p><h4 id="主要对策："><a class="header-anchor" href="#主要对策："></a>主要对策：</h4><ul><li>使用安全的认证框架</li><li>正确加密</li><li>禁用弱口令</li></ul><h3 id="Sensitive-Data-Exposure-（敏感信息泄露）"><a class="header-anchor" href="#Sensitive-Data-Exposure-（敏感信息泄露）"></a>Sensitive Data Exposure （敏感信息泄露）</h3><p>这个问题常见于http传输中，因为http协议是一个明文传输的协议。</p><h4 id="敏感信息定义"><a class="header-anchor" href="#敏感信息定义"></a>敏感信息定义</h4><ul><li>业务流程的敏感信息（肯定不止这些，这里只列出一些比较常见的信息）<ul><li>token</li><li>session</li><li>cookie</li><li>password</li></ul></li><li>用户/客户标识信息<ul><li>电话号码</li><li>身份证号码</li><li>职位</li><li>客户的资产信息（潜在客户，合同信息等）</li><li>生物特征信息（指纹，虹膜等）</li></ul></li></ul><h4 id="保护敏感信息的对策"><a class="header-anchor" href="#保护敏感信息的对策"></a>保护敏感信息的对策</h4><p>敏感信息的保护通常需要贯穿整个业务流程</p><ul><li>在infra层要采用符合标准的TLS版本，（大于等于1.2），并且有选择的禁用密码套件</li><li>采购可信CA的证书，并且定期更新</li><li>对服务器里的用户信息进行脱敏</li><li>使用安全的对称/非对称加密算法</li><li>采用POST方法提交敏感数据</li></ul><h3 id="XML-External-Entities-XXE-（XML-外部处理器漏洞）"><a class="header-anchor" href="#XML-External-Entities-XXE-（XML-外部处理器漏洞）"></a>XML External Entities (XXE)（XML 外部处理器漏洞）</h3><p>XXE通常会出现在基于SOAP的系统中，通常需要启用DTD（document type definitions）。<br>在应用里比较有可能存在的XXE的点是，如果某些功能是通过SAML来完成的，SAML使用XML作为identity assertion<br>另外经过测试，xx应用的Excel文件上传下载部分，不受XXE的影响（XML解析器安全）。<br>另外如果需要整体上快速排查XXE漏洞，可以使用源代码分析工具：<a href="https://owasp.org/www-community/Source_Code_Analysis_Tools" target="_blank" rel="noopener">https://owasp.org/www-community/Source_Code_Analysis_Tools</a></p><h3 id="Broken-Access-Control（中断访问控制）"><a class="header-anchor" href="#Broken-Access-Control（中断访问控制）"></a>Broken Access Control（中断访问控制）</h3><h4 id="原因"><a class="header-anchor" href="#原因"></a>原因</h4><p>限制<strong>认证的用户可以实现哪些操作</strong>的命令没有得到正确的执行。</p><h4 id="问题"><a class="header-anchor" href="#问题"></a>问题</h4><p>攻击者可以利用这些漏洞访问未经授权的功能和数据，例如访问其他用户的账户，查看敏感文件，篡改其他用户的数据，更改访问权限等。</p><h4 id="对策"><a class="header-anchor" href="#对策"></a>对策</h4><ul><li>最小权限原则：只给当前程序运行需要的最小信息或资源。可以有效降低被恶意用户利用时造成的损失</li><li>基于角色的访问控制（对角色权限）：对系统操作的各种权限不是直接授予具体的用户，而是在用户集合与权限集合之间建立一个角色集合。每一种角色对应一组相应的权限。一旦用户被分配了适当的角色后，该用户就拥有此角色的所有操作权限。这样做的好处是，不必在每次创建用户时都进行分配权限的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，这样将简化用户的权限管理，减少系统的开销。</li><li>日志记录访问：对用户的操作进行日志记录，出现异常时可以及时排查原因，可以有效降低损失</li></ul><h3 id="security-misconfiguration（错误安全配置）"><a class="header-anchor" href="#security-misconfiguration（错误安全配置）"></a>security misconfiguration（错误安全配置）</h3><h4 id="原因-v2"><a class="header-anchor" href="#原因-v2"></a>原因</h4><ul><li>安全运营</li><li>比如未修复的漏洞</li><li>访问默认账户</li><li>不再使用的页面</li><li>未受保护的文件和目录等</li></ul><h4 id="对策-v2"><a class="header-anchor" href="#对策-v2"></a>对策</h4><p>程序中接入的第三方提供的东西都需要进行安全配置外，还必须要及时进行更新和升级。</p><h3 id="XSS（跨站脚本攻击）"><a class="header-anchor" href="#XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h3><h4 id="原因-v3"><a class="header-anchor" href="#原因-v3"></a>原因</h4><p>网站将用户输入的内容输出到页面上，在这个过程中可能有恶意代码被浏览器执行</p><p>跨站脚本攻击,它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p><p>需要注意的是XSS是一个完全于客户端触发的安全风险，涉及到服务器端的部分在现实意义的攻击里通常是XSS+CSRF获得用户的Token/Cookie/其他Credentials</p><h4 id="对策-v3"><a class="header-anchor" href="#对策-v3"></a>对策</h4><ul><li>验证所有输入数据，前端对用户提交内容进行内容验证/内容转义</li><li>对输出数据进行适当编码，防止成功注入的恶意脚本被运行</li></ul><p>具体参见下面</p><ul><li>输入验证：某个数据被接受为可被显示或存储之前，使用标准输入验证机制，验证所有输入数据的长度、类型、语法以及业务规则。</li><li>输出编码：数据输出前，确保用户提交的数据已被正确进行entity编码，建议对所有字符进行编码而不仅局限于某个子集。</li><li>明确指定输出的编码方式：不要允许攻击者为你的用户选择编码方式(如ISO 8859-1或 UTF 8)。</li><li>注意黑名单验证方式的局限性：仅仅查找或替换一些字符(如&quot;&lt;&quot; &quot;&gt;&quot;或类似&quot;script&quot;的关键字)，很容易被XSS变种攻击绕过验证机制。</li><li>警惕规范化错误：验证输入之前，必须进行解码及规范化以符合应用程序当前的内部表示方法。请确定应用程序对同一输入不做两次解码。对客户端提交的数据进行过滤，一般建议过滤掉双引号（”）、尖括号（&lt;、&gt;）等特殊字符，或者对客户端提交的数据中包含的特殊字符进行实体转换，比如将双引号（”）转换成其实体形式&quot;，&lt;对应的实体形式是&lt;，&lt;对应的实体形式是&gt;以下为需过滤的常见字符：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[1] |（竖线符号）</span><br><span class="line">[2] &amp; （&amp; 符号）</span><br><span class="line">[3];（分号）</span><br><span class="line">[4] $（美元符号）</span><br><span class="line">[5] %（百分比符号）</span><br><span class="line">[6] @（at 符号）</span><br><span class="line">[7] &#39;（单引号）</span><br><span class="line">[8] &quot;（引号）</span><br><span class="line">[9] \&#39;（反斜杠转义单引号）</span><br><span class="line">[10] \&quot;（反斜杠转义引号）</span><br><span class="line">[11] &lt;&gt;（尖括号）</span><br><span class="line">[12] ()（括号）</span><br><span class="line">[13] +（加号）</span><br><span class="line">[14] CR（回车符，ASCII 0x0d）</span><br><span class="line">[15] LF（换行，ASCII 0x0a）</span><br><span class="line">[16] ,（逗号）</span><br><span class="line">[17] \（反斜杠）</span><br><span class="line">2、在请求返回页面关键字符进行转义；</span><br><span class="line">[1] “（双引号）：&amp;quot</span><br><span class="line">[2] ’ （单引号）：&amp;apos</span><br><span class="line">[3] &amp;（&amp;符号）：&amp;amp</span><br><span class="line">[4] &lt;（左尖括号）：&amp;lt</span><br><span class="line">[5] &gt;（右尖括号）：&amp;gt</span><br><span class="line">在不影响应用的前提下，建议将cookie标记为httpOnly (禁止JS获得Cookie等信息)，同时禁用TRACE方法。</span><br></pre></td></tr></table></figure><h3 id="Insecure-Deserialization（不安全的反序列化）"><a class="header-anchor" href="#Insecure-Deserialization（不安全的反序列化）"></a>Insecure Deserialization（不安全的反序列化）</h3><p>不安全的反序列化最严重的会带来带来RCE（远程代码执行），通常会被用于进行重放攻击，注入攻击和权限提升。</p><h4 id="序列化"><a class="header-anchor" href="#序列化"></a>序列化</h4><p>最严格的禁止反序列化的方式是不接受非受信来源的序列化对象，序列化反序列化问题的根源是语言特性，即面向对象语言所具有的反射机制（动态获得所属类的对象来调用对应的方法）</p><h4 id="对策-v4"><a class="header-anchor" href="#对策-v4"></a>对策</h4><ul><li>缓和方式是在序列化和反序列化的时候进行完整性校验（通常为Hash校验或者签名），也可以进一步进行加密，进行严格类型控制；如果可能，对于不同权限的对象进行隔离，为序列化和反序列化操作提供日志记录，监控inbound/outbound流量，对于持续进行反序列化的操作提供预警。</li><li>关注了解使用了的哪些组件进行了序列化和反序列化操作，他们的实现方式和安全措施是什么，是否启用，是否存在已知的漏洞，定期关注版本发布和升级。</li></ul><h3 id="Using-Components-with-Known-Vulnerabilities（使用含有已知漏洞的组件）"><a class="header-anchor" href="#Using-Components-with-Known-Vulnerabilities（使用含有已知漏洞的组件）"></a>Using Components with Known Vulnerabilities（使用含有已知漏洞的组件）</h3><p>一方面是在选用组件的时候选用名声可信，社区活跃，安全机制较为完善的第三方组件；另一方面需要持续关注新漏洞的发布。</p><h3 id="Insufficient-Logging-Monitoring-（不足的日志和监控）"><a class="header-anchor" href="#Insufficient-Logging-Monitoring-（不足的日志和监控）"></a>Insufficient Logging &amp; Monitoring. （不足的日志和监控）</h3><p>这部分属于安全运营部分，主要是在程序设计时候要留有足够的日志整段信息来追踪漏洞，</p><h3 id="Cross-site-Request-Forgery-跨站请求伪造"><a class="header-anchor" href="#Cross-site-Request-Forgery-跨站请求伪造"></a>Cross-site Request Forgery(跨站请求伪造)</h3><p>这个是培训时没有说明但实际上对FE来说是需要了解的。所以在这里加进来进行补充说明。</p><h4 id="原理"><a class="header-anchor" href="#原理"></a>原理</h4><ul><li><strong>用户C</strong>登录受信任的<strong>站点A</strong></li><li>浏览器生成站点A的cookie信息</li><li>未登出的情况下访问<strong>恶意网站B</strong>（其实登出也不一定，因为不能保证cookie登出后就会失效）</li><li>网站B向网站A发起请求，该请求会带上步骤2的cookie信息</li><li>网站B通过该cookie信息，伪装成用户C进行操作（邮件/信息/转账等等）</li></ul><h4 id="对策-v5"><a class="header-anchor" href="#对策-v5"></a>对策</h4><ul><li>验证 HTTP Referer 字段：Referer字段是用来记录请求的来源地址，因为CSRF一般需要自己构造表单来请求。所以referer字段会不一样，所以对于referer不符合的，直接拒绝请求</li><li>cookie中加入hash： 在cookie中加入hash，然后在后端校验hash值是否正确，来判断请求是否是真的客户发送的</li><li>cookie设置为httpOnly：可以有效减少cookie被获取的风险</li><li>其实总的来说，上面的方法其实防御思路都一样。<strong>就是通过在请求中加入攻击者伪造不了的信息，然后通过这些信息来判断请求是否是真正的客户发送的。当然这些信息不应该存在cookie中</strong></li></ul><h2 id="信息安全设计思路："><a class="header-anchor" href="#信息安全设计思路："></a>信息安全设计思路：</h2><ul><li>系统设计要有适度安全冗余，冗余是指关键功能的安全保障要多层。</li><li>流行的攻击方式要从设计上就预留应对空间。比如SQL Injection要保证使用的数据库支持参数化查询，比如应对不安全的反序列化，要预留设计数字签名校验机制的空间。</li><li>最小化权限原则</li><li>验证用户输入（天然认为用户的输入不安全的设计思路）</li><li>失败默认原则，白名单优先于黑名单</li><li>默认安全，就是默认配置即认为可提供可靠安全。</li><li>权限分离原则，进一步，矩阵访问控制设计。</li><li>服务器端的校验比客户端优先</li></ul><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><p>作为前端，我们也需要了解信息安全的重要性。并且在coding的时候也需要注意程序安全上是否有存在隐患。😘</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;昨天我们团队的&lt;strong&gt;安全大佬&lt;/strong&gt;给我们开展了一个安全培训，怕自己之后很容易会忘掉。所以写篇文章来记录一些常见的安全问题以及应对策略
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="信息安全" scheme="https://xzh97.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议学习（一）</title>
    <link href="https://xzh97.github.io/2020/08/01/http-protocol/"/>
    <id>https://xzh97.github.io/2020/08/01/http-protocol/</id>
    <published>2020-08-01T02:40:46.000Z</published>
    <updated>2020-09-27T14:25:37.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>本文主要是为了记录平时阅读&lt;&lt;HTTP权威指南&gt;&gt;的一些知识点的。 把它们抽离出来，记录在本篇文章中，方便平时的理解</p><h3 id="URI（Uniform-Resource-Identifier，统一资源标识符）"><a class="header-anchor" href="#URI（Uniform-Resource-Identifier，统一资源标识符）"></a>URI（Uniform Resource Identifier，统一资源标识符）</h3><p><code>URI</code>的作用是<strong>指示http协议去获取对应服务器上的数据</strong>。它有两种形式，分别是<code>URL（Uniform Resource Locator 统一资源定位符）</code>和<code>URN（Uniform Resource Name 统一资源名）</code>。</p><p>我们当前的所用的几乎所有的<code>URI</code>都是<code>URL</code>形式，<code>URN</code>由于缺少架构支撑，目前还只能在实验阶段。所以之后我们说的<code>URI</code>指的都是<code>URL</code>。</p><h3 id="URL"><a class="header-anchor" href="#URL"></a>URL</h3><h4 id="格式"><a class="header-anchor" href="#格式"></a>格式</h4><p>根据<a href="https://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">RFC 1738</a>,URL的格式为以下：</p><blockquote><p>“…Only alphanumerics [0-9a-zA-Z], the special characters “$-_.+!*’(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;翻译</span><br><span class="line">只有字母和数字[0-9a-zA-Z]、一些特殊符号&#96;$-_.+!*&#39;()&#96;,以及某些保留字，才可以不经过编码直接用于URL。</span><br></pre></td></tr></table></figure><h4 id="组成"><a class="header-anchor" href="#组成"></a>组成</h4><p>一般来说，URL由三部分组成：</p><ol><li>协议（scheme）：指明访问资源使用的协议类型</li><li>服务器（host:port）：服务器地址</li><li>本地资源（url-path）：访问的资源在服务器的路径</li></ol><h3 id="HTTP协议"><a class="header-anchor" href="#HTTP协议"></a>HTTP协议</h3><h4 id="HTTP报文"><a class="header-anchor" href="#HTTP报文"></a>HTTP报文</h4><ul><li>起始行：内容主要是<code>http version，http status，method，url</code>等</li><li>首部字段：<code>request Headers &amp; response Headers</code></li><li>主体：真正传输的数据</li></ul><h3 id="HTTP连接"><a class="header-anchor" href="#HTTP连接"></a>HTTP连接</h3><p><a href="https://xzh97.github.io/2020/01/15/url-parse/">URL从输入到页面展示的过程</a></p><h3 id="TCP协议"><a class="header-anchor" href="#TCP协议"></a>TCP协议</h3><p>HTTP只是一个应用层协议，本身并不关注数据的传输，负责传输数据的就是协议就是用的传输层TCP/IP协议。</p><p>TCP（Transmission Control Protocol），意为：传输控制协议。TCP可以给我们带来通用的、可靠的传输协议。</p><p>TCP传输的数据有以下几点特点：</p><ul><li>无差错： 不会不传，漏传，多传。</li><li>按序传输：传输的报文顺序不会出错。</li><li>未分段的数据流：可以在任意时间以任意大小传输</li></ul><h4 id="TCP协议的可靠性如何保证？"><a class="header-anchor" href="#TCP协议的可靠性如何保证？"></a>TCP协议的可靠性如何保证？</h4><p>那么，TCP是如何保证自己传输的数据是可靠的呢？</p><ul><li><p>校验和：</p><ul><li>发送端：原码相加，将高位叠加到低位，取反，得到反码求和结果，加入校验和字段</li><li>接收端：将所有原码相加，高位叠加，如全为1，则正确</li><li>结果：如果校验和出错，此数据包会被放弃。</li></ul></li><li><p>确认应答和序列号：</p><ul><li>序列号：所有数据包会依序编号</li><li>确认应答：接收方接收到数据之后就会确认</li></ul></li><li><p>超时重传：数据包传出之后，会启动一个计时器，一旦数据传输超时，TCP就会重新发送超时的数据包。</p><p><strong>注意：超时以500ms为单位，每次判定超时重发的超时时间都是500ms的整数倍且重发时间按照指数增长，计算方式为<code>2^重发次数*500ms</code></strong></p></li><li><p>连接管理：三次握手和四次挥手</p></li><li><p>流量控制：TCP连接的两端都有接收数据的一个缓冲区，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。如果数据发送过快，就控制流量的发送速度且把改变的速度发到发送端</p></li><li><p>拥塞控制：当前网络拥堵时，传送的数据过慢会导致超时，然后TCP会进行重发，会造成网络更加拥堵，所以此时会减少发送数据速率。 这里和流量控制不一样的地方在于，流量控制是为了接收端能及时接收到数据，而拥塞控制是为了降低网络堵塞的程度</p><p>拥塞控制主要通过以下几个算法</p><ul><li>慢开始算法</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul></li></ul><h4 id="三次握手"><a class="header-anchor" href="#三次握手"></a>三次握手</h4><p>TCP的三次握手其实就是对服务端状态和客户端状态做一个确认，这也是对TCP可靠性的一个支撑。接下来说一下三次握手的过程：</p><ol><li>第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><h4 id="四次挥手"><a class="header-anchor" href="#四次挥手"></a>四次挥手</h4><p>TCP的四次挥手用于释放TCP连接，具体过程如下：</p><ol><li>客户端发送数据包给服务端并进入<strong>终止等待1</strong><code>FIN-WAIT-1</code>状态</li><li>服务端接收数据包,然后返回一个数据包给客户端并进入<strong>半关闭</strong><code>CLOSE-WAIT</code>状态，客户端接收到数据包进入<strong>终止等待2</strong><code>FIN-WAIT-2</code>状态</li><li>服务端发送数据包给客户端并进入<strong>最后确认</strong><code>LAST-ACK</code>状态</li><li>客户端发送数据包给服务端，然后进入<strong>时间等待</strong><code>TIME-WAIT</code>状态，在经过<code>2MSL</code>（<code>MSL</code>是指一个网络片段的最大存活时间，<code>2MSL</code>刚好是一个发送和返回的最大时间）之后，客户端进入<strong>关闭</strong><code>CLOSED</code>状态，服务端接收到数据包之后立马进入<strong>关闭</strong><code>CLOSED</code>状态</li></ol><h4 id="滑动窗口技术"><a class="header-anchor" href="#滑动窗口技术"></a>滑动窗口技术</h4><p>TCP中实际的传输数据方式。要了解滑动窗口技术，我们首先得了解窗口机制。<strong>窗口实际上就是数据传输的管道</strong>。窗口大小跟数据传输量成正相关。</p><p>滑动窗口技术实质上就是指<strong>通过动态控制数据窗口大小来调节两台主机间的数据传输速率</strong>，上面的流量控制和拥塞控制实际上都是通过滑动窗口技术来完成的。</p><h3 id="Web页面的结构组件"><a class="header-anchor" href="#Web页面的结构组件"></a>Web页面的结构组件</h3><p>Web不只有浏览器和服务器，还有一些其它的重要的程序。</p><p>主要有以下一些：</p><ul><li>代理：代理就是在浏览器和服务器之间的一层中间实体，它的作用在于对http请求进行<strong>封装/拦截/过滤/监控</strong>。</li><li>缓存：作用就是把请求到的数据保存到内存/本地中，使得用户请求数据的数据如果没有变化时可以不用与服务端进行请求连接，而可以直接从本地/内存里取已有的数据</li><li>网关：资源处理器/协议转换器，可以用来对请求进行响应或者对协议进行处理。</li><li>隧道：使得用户可以通过http程序访问非http协议的程序</li><li>agent代理：代表用户对http发起请求的程序，目前我们的web浏览器就是一种agent代理。爬虫程序也是agent代理</li></ul><h3 id="HTTPS"><a class="header-anchor" href="#HTTPS"></a>HTTPS</h3><p>首先，我们都知道HTTP请求其实是明文传输的，但是这样的话一些隐私的信息就很容易被别人知道。所以为了保护隐私信息，推出了HTTPS，通俗的讲，HTTPS其实就是在HTTP连接中新增了一层安全层面的处理。</p><p>HTTP的连接过程是这样的：发送端 --&gt; HTTP --&gt; TCP --&gt; IP。</p><p>而HTTPS其实就是在HTTP --&gt; TCP这里加了一层SSL层来对数据进行加密保护。</p><h4 id="服务器证书-Server-Certificates"><a class="header-anchor" href="#服务器证书-Server-Certificates"></a>服务器证书(Server Certificates)</h4><p>要想了解HTTPS，我们还得先了解一下服务器证书是什么。</p><p>服务器证书是一个显示了组织的名称、地址、服务器 DNS 域名以及其他信息的 X.509 v3 派生证书（参见图 14-17）。你和你所用的客户端软件可以检查证书，以确 保所有的信息都是可信的。</p><p>它是组成Web服务器的SSL安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您Web站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。这意味着服务器证书确保用户关于web服务器内容的验证，同时意味着建立的HTTP连接是安全的。</p><h5 id="HTTPS证书包含了哪些内容"><a class="header-anchor" href="#HTTPS证书包含了哪些内容"></a>HTTPS证书包含了哪些内容</h5><p><img src="http://122.51.73.210:3000/upload/2020-9-24/20209248424.png" alt="HTTPS证书内容"></p><h4 id="浏览器如何校验证书"><a class="header-anchor" href="#浏览器如何校验证书"></a>浏览器如何校验证书</h4><p>网景公司提出的一种 Web 服务器证书有效性算法是大部分浏览器有效性验证技术的基础。验证步骤如下所述</p><h5 id="日期检测"><a class="header-anchor" href="#日期检测"></a>日期检测</h5><p>首先，浏览器检查证书的起始日期和结束日期，以确保证书仍然有效。如果证书过期了，或者还未被激活，则证书有效性验证失败，浏览器显示一条错误信息。</p><h5 id="签名颁发者可信度检测。"><a class="header-anchor" href="#签名颁发者可信度检测。"></a>签名颁发者可信度检测。</h5><p>每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。证书有不同的等级，每种证书都要求不同级别的背景验证。比如，如果申请某个电子商务服务器证书，通常需要提供一个营业的合法证明。</p><p>任何人都可以生成证书，但有些 CA 是非常著名的组织，它们通过非常清晰的流 程来验证证书申请人的身份及商业行为的合法性。因此，浏览器会附带一个签 名颁发机构的受信列表。如果浏览器收到了某未知（可能是恶意的）颁发机构<br>签发的证书，那它通常会显示一条警告信息。有些证书会携带到受信 CA 的有效 签名路径，浏览器可能会选择接受所有此类证书。换句话说，如果某受信 CA 为 “Sam 的签名商店”签发了一个证书，而 Sam 的签名商店也签发了一个站点证 书，浏览器可能会将其作为从有效 CA 路径导出的证书接受。</p><h5 id="签名检测"><a class="header-anchor" href="#签名检测"></a>签名检测</h5><p>一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性。</p><h5 id="站点身份检测"><a class="header-anchor" href="#站点身份检测"></a>站点身份检测</h5><p>为防止服务器复制其他人的证书，或拦截其他人的流量，大部分浏览器都会试着 去验证证书中的域名与它们所对话的服务器的域名是否匹配。服务器证书中通常 都包含一个域名，但有些 CA 会为一组或一群服务器创建一些包含了服务器名称 列表或通配域名的证书。如果主机名与证书中的标识符不匹配，面向用户的客户 端要么就去通知用户，要么就以表示证书不正确的差错报文来终止连接。</p><h4 id="整体请求过程"><a class="header-anchor" href="#整体请求过程"></a>整体请求过程</h4><p>HTTPS的请求过程大致可以分为两个部分，一个是证书验证，一个是数据传输，具体的交互过程如下图所示:<br><img src="http://122.51.73.210:3000/upload/2020-9-24/20209243367.jpg" alt="https的加密验证和数据传输过程"></p><h4 id="加密验证和数据传输的具体过程"><a class="header-anchor" href="#加密验证和数据传输的具体过程"></a>加密验证和数据传输的具体过程</h4><p>待添加具体内容</p><h3 id="参考"><a class="header-anchor" href="#参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qq_42046105/article/details/103396972" target="_blank" rel="noopener">【图文讲解】你一定能看懂的HTTPS原理剖析！</a></li><li><a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6/808219?fr=aladdin" target="_blank" rel="noopener">服务器证书-百度百科</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要是为了记录平时阅读&amp;lt;&amp;lt;HTTP权威指南&amp;gt;&amp;gt;的一些知识点的。 把它们抽离出来，记录在本篇文章中，方便平时的理解&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://xzh97.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="http" scheme="https://xzh97.github.io/tags/http/"/>
    
      <category term="协议" scheme="https://xzh97.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>组件设计思考-CustomTransfer</title>
    <link href="https://xzh97.github.io/2020/07/22/component-design-custom-transfer/"/>
    <id>https://xzh97.github.io/2020/07/22/component-design-custom-transfer/</id>
    <published>2020-07-22T13:40:46.000Z</published>
    <updated>2020-09-27T14:25:16.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件设计"><a class="header-anchor" href="#组件设计"></a>组件设计</h2><h3 id="前言"><a class="header-anchor" href="#前言"></a>前言</h3><p>本来之前部门那边有这样类似的框，我还以为这个组件是通用组件，结果发现并不是。而且选择部门那块业务相关代码实在太多。所以此次需求里，我准备写个通用的</p><h3 id="设计"><a class="header-anchor" href="#设计"></a>设计</h3><h4 id="成品图"><a class="header-anchor" href="#成品图"></a>成品图</h4><p><img src="http://122.51.73.210:3000/upload/2020-07-22/202007224899.jpg" alt="image"></p><h3 id="组件实例之CustomTransfer组件设计"><a class="header-anchor" href="#组件实例之CustomTransfer组件设计"></a>组件实例之CustomTransfer组件设计</h3><h4 id="设计思路"><a class="header-anchor" href="#设计思路"></a>设计思路</h4><h5 id="内容布局"><a class="header-anchor" href="#内容布局"></a>内容布局</h5><p><img src="http://122.51.73.210:3000/upload/2020-07-22/20200722319.png" alt="image"></p><h5 id="数据处理"><a class="header-anchor" href="#数据处理"></a>数据处理</h5><ul><li>通用数据格式:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    key: &#39;&#39;,  &#x2F;&#x2F; 索引，做diff用</span><br><span class="line">    value: &#39;&#39;, &#x2F;&#x2F; 变量value</span><br><span class="line">    label: &#39;&#39;, &#x2F;&#x2F; 变量名称</span><br><span class="line">    type: &#39;&#39;, &#x2F;&#x2F; 变量类型</span><br><span class="line">    children:[] &#x2F;&#x2F; 变量子级数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据获取方式<ul><li>外部传入<code>dataSource</code></li><li>外部传入<code>method, getUrl, extraParams, searchKey</code></li></ul></li><li>数据转换方式：<ul><li>传入<code>labelKey，valueKey，childKey，typeKey</code>然后通过<code>formater</code>转换数据格式。</li></ul></li></ul><h4 id="交互"><a class="header-anchor" href="#交互"></a>交互</h4><ul><li>未弹框显示一个<code>multiple</code>模式的<code>select</code>控件</li><li>点击<code>Select</code> 出现<code>Modal</code>弹框</li><li>左上<code>Input</code>可以实时模糊查询</li><li>搜索出的列表展示在左下方，点击列表<code>item</code>来选择控件，若传入<code>typeCheck</code>，则点击时对选择做类型校验</li><li>已选择的列表展示在右下方，可以点击右侧X样式的<code>icon</code>删除</li><li>点击取消 不保存已选择控件列表</li><li>点击确定，保存已选择控件列表</li></ul><h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3><ul><li>布局清晰，各模块功能思路清楚，可读性好。</li><li>在外部加载数据传入组件内，由于组件在外部可能并发使用较多，所以为了避免同时调用此接口，建议在外部传入<code>dataSource</code>。</li></ul><h3 id="不足"><a class="header-anchor" href="#不足"></a>不足</h3><ul><li>传入的<code>typeCheck</code>和<code>isError</code>属性，这里并不符合我的预期。因为这里是业务的需求，而不是组件本身的需求。但由于外部页面布局未使用<code>FormItem</code>包裹，不好做处理保存的报错提示处理。</li><li>组件设计也许可以更好</li></ul><h3 id="思考"><a class="header-anchor" href="#思考"></a>思考</h3><ul><li>对组件做一个大致的布局，可以清晰的知道有哪些交互需要实现。</li><li>对传入的数据作适配处理，这里也是暂时有点困惑我的地方，因为不同接口数据格式可能不同，目前设计中，是在外部传入<code>valueKey</code>，<code>labelKey</code>，<code>childKey</code>来判断。这里可以思考下是否有更好的处理方式</li><li>在加入业务需求处理时，这里更好的处理方式是写一个新的业务组件，然后把<code>customTransfer</code>作为一个子组件加进去，其它地方加入业务处理。 而不应该直接加进来。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件设计&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#组件设计&quot;&gt;&lt;/a&gt;组件设计&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;
&lt;p&gt;本来之前部门那边有这样
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://xzh97.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="组件设计" scheme="https://xzh97.github.io/tags/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码学习（一）：响应式-1</title>
    <link href="https://xzh97.github.io/2020/05/12/vue-reactivty/"/>
    <id>https://xzh97.github.io/2020/05/12/vue-reactivty/</id>
    <published>2020-05-12T04:39:34.000Z</published>
    <updated>2020-07-22T14:48:11.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="header-anchor" href="#前言"></a>前言</h3><p>首先声明一下，本来计划是一月一篇，三月加了一整个月的班，9107的这种，真挺累的。所以四月份就没有写了，而且最近觉得有道云笔记挺好用，所以很多东西都先在有道云里写了。就看后面啥时候有空贴出来。好了，步入正题。其实在这之前呢，就陆陆续续的阅读过<code>vue2</code>的源码，但是看的都零零散散的，这次决定来系统的解读下<code>vue2</code>的源码，希望自己能对<code>vue2</code>掌握的更加深刻以及提升自己的水平。这篇文章主要解读一下<code>vue2</code>的响应式原理，why？ 因为这个问题实在是太常见了。😜</p><h3 id="过程图"><a class="header-anchor" href="#过程图"></a>过程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">有道云笔记的过程图实在太丑了，我之后用其他的软件画一个QWQ</span><br><span class="line">&lt;!--graph TD</span><br><span class="line">    A[data&#x2F;props]</span><br><span class="line">    A --&gt; B(defineReactive)</span><br><span class="line">    B --&gt; |tracking| D[依赖收集]</span><br><span class="line">    B --&gt; |trigger| E[触发]</span><br><span class="line">    D --&gt; |depend| F[Dep]</span><br><span class="line">    E --&gt; |notify| F[Dep]</span><br><span class="line">    </span><br><span class="line">    G[computed]</span><br><span class="line">    G --&gt; H(computedWatcher)</span><br><span class="line">    H --&gt; |tracking| I[依赖收集]</span><br><span class="line">    H --&gt; |trigger| J[依赖收集]</span><br><span class="line">    I --&gt; |depend| F[Dep]</span><br><span class="line">    J --&gt; |notify| F[Dep]</span><br><span class="line">    </span><br><span class="line">    K[watch]</span><br><span class="line">    K --&gt; L(Watcher)</span><br><span class="line">    L --&gt; |update| F[Dep]</span><br><span class="line">    L --&gt; |addDep| F[Dep]</span><br><span class="line">    L --&gt; |run| M(callback)</span><br><span class="line">    </span><br><span class="line">    N[$mount]</span><br><span class="line">    N --&gt; O(render watcher)</span><br><span class="line">    N --&gt; P(updateComponent)</span><br><span class="line">    N --&gt; |update| F[Dep]</span><br><span class="line">    N --&gt; |addDep| F[Dep]--&gt;</span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a class="header-anchor" href="#Object-defineProperty"></a>Object.defineProperty</h3><blockquote><p>Object.defineProperty()，它会在一个对象上定义一个新属性，或者修改一个对象的现有属性并返回此对象</p></blockquote><p>vue的响应式主要是通过<code>Object.defineProperty()</code>来完成的。但由于<code>Object.defineProperty()</code>是<code>ES5</code>的内容，所以<code>vue</code>本身兼容不了<code>ie8</code>。这里大致说明一下<code>Object.defineProperty()</code>的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zh'</span>,</span><br><span class="line">  age: <span class="string">'23'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的赋值等价于</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">'name'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'zh'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">'age'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>, <span class="comment">// 是否可枚举</span></span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">// 是否可以被改变以及被删除</span></span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">// 是否可以被赋值</span></span><br><span class="line">    value: <span class="number">23</span> <span class="comment">// 赋值， 不写value 默认赋值undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// enumerable，configurable，writable，value被称为数据描述符，</span></span><br><span class="line"><span class="comment">// enumerable，configurable，get(),set()被称为存取描述符。</span></span><br><span class="line"><span class="comment">//enumerable，configurable同时是两种描述符，数据描述符和存取描述符不能同时存在，同时存在时会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">    <span class="comment">// 是一个给key提供的getter方法，当我们 访问 该key值的时候会被触发</span></span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`get<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是一个给key提供的setter方法，当我们 改变 该key值的时候会被触发</span></span><br><span class="line">    <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`set变化，<span class="subst">$&#123;key&#125;</span>的newVal是<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);</span><br><span class="line">obj.name = <span class="string">'zh1'</span>;</span><br></pre></td></tr></table></figure><p>当我们给<code>obj</code>设置好了<code>get</code>和<code>set</code>之后，我们就可以简单的把这个对象称为是一个响应式对象。那么，<code>vue</code>中的响应式对象究竟是怎么样的呢？</p><h3 id="响应式对象入口"><a class="header-anchor" href="#响应式对象入口"></a>响应式对象入口</h3><p>想了解响应式，我们先看下<code>vue</code>的初始化过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue的最初入口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options) </span><br><span class="line">  <span class="comment">// 我们可以看到vue调用时其实就调用了一个_init方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义了_init方法</span></span><br><span class="line">initMixin(Vue)</span><br><span class="line"><span class="comment">// 添加数据相关处理方法，$set,$delete,$watch</span></span><br><span class="line">stateMixin(Vue)  </span><br><span class="line"><span class="comment">// 添加事件方法，$on,$once,$off,$emit</span></span><br><span class="line">eventsMixin(Vue)</span><br><span class="line"><span class="comment">// 添加生命周期方法， _update,$forceUpdate,$destory</span></span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line"><span class="comment">// 添加渲染相关处理 $nextTick, _render</span></span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// _init方法内容</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm) <span class="comment">// 初始化生命周期相关</span></span><br><span class="line">    initEvents(vm) <span class="comment">// 初始化事件中心相关</span></span><br><span class="line">    initRender(vm) <span class="comment">// 初始化渲染相关</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>) </span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="comment">// 数据初始化，响应式原理 start</span></span><br><span class="line">    initState(vm) <span class="comment">// 可以看到这里是我们的目标</span></span><br><span class="line">    <span class="comment">// 数据初始化，响应式原理 end</span></span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// initState 数据初始化。根据你传入的options的内容决定需要跑哪些对应的数据初始化方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="comment">// 在这里的初始化其实没有啥特别的东西，主要逻辑如下：</span></span><br><span class="line">  <span class="comment">// 1. 数据是否重复声明</span></span><br><span class="line">  <span class="comment">// 2. 通过proxy处理数据，使得我们可以通过this.xx来访问数据</span></span><br><span class="line">  <span class="comment">// 3. 对传入的数据做响应式处理</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化传入的data数据。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// data为什么是以方法传入的？</span></span><br><span class="line">  <span class="comment">// vue实例可能是组件。而对于组件来说，每个组件的data应该是独立存在的，不能互相影响。 </span></span><br><span class="line">  <span class="comment">// 所以说data为什么推荐的是传入function</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="comment">// 防止重复变量声明</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">    <span class="comment">// 代理方法</span></span><br><span class="line">    <span class="comment">// 我们的this.xx属性实际是访问的this._data.xx</span></span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 重点地方， 响应式处理的方法</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="observe"><a class="header-anchor" href="#observe"></a>observe</h3><p><code>observe</code>定义在<code>core/instance/observer.js</code>中。我们看下<code>observe</code>里做了哪些事情。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否是对象以及是否为v-dom</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">  <span class="comment">// 缓存处理</span></span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">  <span class="comment">// 实例化一个Observer类</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>observe()</code>主要是对传入的<code>value</code>做了是否缓存过的判断，然后返回的仍然是一个<code>Observer</code>实例对象。接下来我们看一下<code>Observer</code>里做了什么处理</p><h3 id="Observer"><a class="header-anchor" href="#Observer"></a>Observer</h3><p>Observer的定义和observe方法在同一个文件中，我们可以看到<code>Observer</code>是一个类。我们看下这个类中做了哪些处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line">  vmCount: number; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value <span class="comment">// 传入值</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep() <span class="comment">// 声明Dep类</span></span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 绑定Observer实例到value的__ob__属性上</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>) </span><br><span class="line">    <span class="comment">// todo 看代码注释说是拦截，然后加强对array的处理。具体需要看后面是怎么用的。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对对象做一个声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj: Object, key: string, val: any, enumerable?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以知道，<code>Observer</code>类就是给传入的<code>object/array</code>设置<code>getter</code>和<code>setter</code>，并没有做什么太多的处理，就是声明了一个<code>Dep</code>类。然后把自身实例设置到<code>value</code>的<code>__ob__</code>属性上，最后就是对对象和数组的差异化处理。</p><h3 id="defineReactive"><a class="header-anchor" href="#defineReactive"></a>defineReactive</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这才是真正声明一个响应式对象的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 判断是否可以改变obj的值</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      <span class="comment">// 触发更新</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以知道，<code>defineReactive()</code>主要是通过<code>Object.defineProperty()</code>对<code>obj</code>设置<code>getter</code>和<code>setter</code>。并且还对<code>childObj</code>进行了<code>observe</code>操作，这样就能保证不管<code>obj</code>的结构多复杂，都能够把子属性变成响应式对象并能在访问或修改时及时的触发<code>getter</code>或<code>setter</code>。最后，我们在<code>getter</code>中进行依赖收集的操作，在<code>setter</code>中触发更新的操作。</p><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><p><code>vue</code>的响应式核心就是通过<code>Object.defineProperty()</code>来对传入对象添加<code>getter</code>和<code>setter</code>。由于篇幅已经挺长的了，之后的依赖收集和触发更新放到下一篇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;
&lt;p&gt;首先声明一下，本来计划是一月一篇，三月加了一整个月的班，9107的这种，真挺累的。所以四月份就没有写了，而且最近觉得有道云笔记挺好用，所以很多东西都先在有
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://xzh97.github.io/tags/vue/"/>
    
      <category term="源码" scheme="https://xzh97.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="响应式" scheme="https://xzh97.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面展示的过程</title>
    <link href="https://xzh97.github.io/2020/01/15/url-parse/"/>
    <id>https://xzh97.github.io/2020/01/15/url-parse/</id>
    <published>2020-01-15T12:56:57.000Z</published>
    <updated>2020-07-22T14:49:49.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>讲道理，之前说过的一<s>天</s>月一篇其实是开玩笑的。莫名其妙就这么久没写过博客了。今天在回家的路上突然想起了这个问题----“从输入url到页面展示的过程有哪些？”。其实也不算突然吧，其实想想好像看面试题的时候经常会出现这么一道题目。今天就照着自己想到的东西来写这么一篇。</p><h2 id="过程"><a class="header-anchor" href="#过程"></a>过程</h2><ul><li>DNS解析输入的域名<ul><li>目的：解析域名获取ip</li><li>过程：<ol><li>浏览器缓存中查找是否有该域名对应的ip地址</li><li>操作系统缓存中查找是否有该域名对应的ip地址</li><li>向本地域名服务器来请求解析</li><li>向上一级域名服务器请求解析</li><li>重复4步骤，一直到根服务器为止</li><li>返回解析出的结果，并且缓存到本地域名服务器以及操作系统缓存中</li></ol></li></ul></li><li>向服务端发出TCP连接<ul><li>目的：获取稳定可靠的连接</li><li>TCP三次握手过程：<ol><li>客户端向服务端发出一个数据包</li><li>服务端接收到客户端发送的数据包并打上确认的标记，然后返回给客户端</li><li>客户端接收到数据包，加上确认标记。再次发送给服务端。</li><li>建立连接</li></ol></li></ul></li><li>web端发送请求，服务端返回资源给客户端。</li><li>web端解析并渲染资源（正常结构）<ul><li>知识点：web端如何渲染</li><li>渲染过程：<ol><li>解析HTML文档构建DOM树，解析CSS构建CSSOM</li><li>DOM树和CSSOM合并成一个节点树</li><li>浏览器通过节点树计算节点在页面所处的位置</li><li>浏览器渲染节点</li></ol></li><li>其它知识：<ol><li>重绘：节点的视觉属性发生变化，例如<code>color</code>,<code>font</code>等的变化，引起的浏览器重新绘制节点的行为。</li><li>回流：节点的位置属性发生变化，例如<code>left,top,right,bottom,display:none,width,height</code>等的变化，引起的浏览器重新计算节点位置并绘制节点的行为</li><li>重绘和回流的关系： 重绘不一定回流，回流必然会引起重绘</li><li>优化：<ul><li>尽量避免直接操作DOM节点</li><li>可以使用<code>position</code>把一些复杂动画的节点脱离文档流。从而避免其父元素及周围元素发生变化从而引起回流</li></ul></li></ol></li></ul></li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>以上就是对url输入到页面展示的过程的一些知识的理解和总结。其实还可以再往细来讲，不过由于自己知识水平有限，对于网络协议以及数据包结构的理解不深，想了想还是不丢人现眼了哈哈哈。<br>That’s all!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;讲道理，之前说过的一&lt;s&gt;天&lt;/s&gt;月一篇其实是开玩笑的。莫名其妙就这么久没写过博客了。今天在回家的路上突然想起了这个问题----“从输入url到页面展示
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://xzh97.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="https://xzh97.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>hexo添加gitalk作为博客评论系统</title>
    <link href="https://xzh97.github.io/2019/12/18/hexo-add-gitalk/"/>
    <id>https://xzh97.github.io/2019/12/18/hexo-add-gitalk/</id>
    <published>2019-12-18T14:55:05.000Z</published>
    <updated>2020-08-24T14:21:12.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>莫得评论的博客莫得灵魂——<s>鲁迅</s>。</p><h2 id="Gitalk是什么"><a class="header-anchor" href="#Gitalk是什么"></a>Gitalk是什么</h2><p>Gitalk 一开始应该是<code>github</code>推出来配合搭建博客而做的评论插件。然而随着其他评论插件的没落，Gitalk 就火起来了。<br>它基于 <code>Github Issue</code> 和 <code>Preact</code> 开发。<br>除了支持 <code>Hexo</code> 外，还支持 <code>java</code>，<code>php</code> 等语言开发的博客。</p><h2 id="为啥用Gitalk"><a class="header-anchor" href="#为啥用Gitalk"></a>为啥用Gitalk</h2><p>之前其实还去看了其它的评论插件。一开始是打算用<code>duoshuo</code>或者<code>disqus</code>这两个插件其中一个（apollo主题自带）。然后:</p><ul><li><code>duoshuo</code>已经停止服务（还有网易云更贴）</li><li><code>disqus</code>的需要<s>科学上网</s></li><li>然后在寻找其它插件的时候碰巧看到了<code>Gitalk</code>，一定是特别的缘分。（其实是看到了<code>git</code>三个字眼）</li></ul><p><strong>搭建步骤</strong></p><ol><li>在github搭建一个仓库来存放评论(因为我的hexo博客是和githubPage绑定的，就不创建新的了。直接用的我的博客仓库)</li><li>把仓库Issue开启（这个好像是默认开启的，如果没改的话就不用动了）</li><li>注册申请一个<code>Github Application</code>(<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击此处可进入</a>)<br>创建好了之后，复制你的<code>ClientID，ClientSecret</code>。</li><li>在<code>hexo</code>主题下的<code>config.yml</code>文件加入这段：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#用来做启用判断可以不用，目前没有写相关逻辑</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="comment">#Github 用户名,</span></span><br><span class="line">    <span class="attr">repo:</span>  <span class="comment">#储存评论issue的github仓库名</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">[]</span> <span class="comment">#Github 用户名,</span></span><br><span class="line">    <span class="attr">oauth:</span></span><br><span class="line">        <span class="attr">clientID:</span>  <span class="comment">#`Github Application clientID`</span></span><br><span class="line">        <span class="attr">clientSecret:</span>  <span class="comment">#`Github Application clientSecret`</span></span><br></pre></td></tr></table></figure><ol start="5"><li>找到<code>hexo</code>主题内的评论模板<code>comment.jade</code>和头部模板<code>head.jade</code>，在里面新加以下代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 我提前把gitalk的css和js文件下载到本地了</span><br><span class="line">&#x2F;&#x2F; 同时其中的代码根据不同的模板也不一样，这里用的jade仅供参考</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; head</span><br><span class="line">if theme.gitalk.enable</span><br><span class="line">    link(rel&#x3D;&quot;stylesheet&quot;, href&#x3D;url_for(&quot;css&#x2F;gitalk.1.5.0.css&quot;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; comment</span><br><span class="line">if theme.gitalk.enable</span><br><span class="line">    #gitalk-container</span><br><span class="line">    script(src&#x3D;url_for(&quot;js&#x2F;gitalk.1.5.0.min.js&quot;))</span><br><span class="line">    script.</span><br><span class="line">        var params &#x3D; &#123;</span><br><span class="line">            clientID:&quot;#&#123;theme.gitalk.oauth.clientID&#125;&quot;,</span><br><span class="line">            clientSecret:&quot;#&#123;theme.gitalk.oauth.clientSecret&#125;&quot;,</span><br><span class="line">            repo:&quot;#&#123;theme.gitalk.repo&#125;&quot;,</span><br><span class="line">            admin:&quot;#&#123;theme.gitalk.admin&#125;&quot;,</span><br><span class="line">            id:window.location.pathname,</span><br><span class="line">            owner:&quot;#&#123;theme.gitalk.owner&#125;&quot;,</span><br><span class="line">            distractionFreeMode: false,</span><br><span class="line">        &#125;;</span><br><span class="line">        var gitalk &#x3D; new Gitalk(params)</span><br><span class="line">        gitalk.render(&#39;gitalk-container&#39;);</span><br></pre></td></tr></table></figure><p><strong>遇到的问题</strong><br>一开始，我发现在调用github的api时总是报错，返回状态码为:422。由于之前422我从来没有碰到过。于是我就去搜索了一下422的含义：<br><strong>422 Unprocessable Entity：请求格式正确，但是由于含有语义错误，无法响应。422 则表现为请求格式错误，但出现了 语义 错误，以至于服务端无法响应。可以理解为服务端能理解请求资源类型<code>content-type</code>，否则应该返回 415（Unsupported Media Type），也能理解请求实体内容，否则应该返回 400（Bad Request）。</strong><br>后面我根据接口去慢慢调试，发现是请求体中的<code>label=['Gitalk,location.pathname']</code>参数内包含了<code>location.pathname</code>导致的错误。其实这里我并没想传这个<code>location.pathname</code>,我传的应该是<code>pathname</code>的<code>value</code>才对。 然后我才发现，原来<code>config.yml</code>里面的内容其实都是<code>string</code>类型。于是把<code>params.id</code>写在了<code>comment.jade</code>里。最后成功解决了问题。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>所以说，平时还是要细心点才好。不过这波也不亏。学到了http状态码的知识。422（<strong>格式正确，语义有错误</strong>），415（<strong>不支持该请求资源类型</strong>）,400（<strong>请求实体内容有误。这个一般是请求体内的参数有问题</strong>）<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;莫得评论的博客莫得灵魂——&lt;s&gt;鲁迅&lt;/s&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Gitalk是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://xzh97.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xzh97.github.io/tags/hexo/"/>
    
      <category term="gitalk" scheme="https://xzh97.github.io/tags/gitalk/"/>
    
      <category term="apollo" scheme="https://xzh97.github.io/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>BFC总结</title>
    <link href="https://xzh97.github.io/2019/12/16/css-bfc/"/>
    <id>https://xzh97.github.io/2019/12/16/css-bfc/</id>
    <published>2019-12-16T14:04:16.000Z</published>
    <updated>2020-07-22T14:49:46.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>今天在题目里看到了BFC的提问，虽然之前对于BFC有粗浅的了解过。但是到目前为止已经比较久远了，对BFC的记忆已经不是很清楚了。只记得BFC的触发方法以及用户。所以今天写这篇文章来对之前的学习做一个总结。</p><p><strong>BFC是什么？</strong><br>BFC全称为块级格式上下文（Block Formatting Context）。是CSS的一种渲染机制。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p><strong>BFC规则</strong></p><ul><li>内部的盒子会在垂直方向，一个接一个的排列</li><li>盒子垂直方向的距离由<code>margin</code>来决定，属于同一个BFC的两个盒子，在相邻方向的外边距会发生重叠</li><li>BFC区域不会和<code>float</code>盒子区域重叠。</li><li>BFC就是页面上的一个隔离的独立容器， 容器内的子元素和BFC外面的元素互不影响.</li><li>对于从左往右的格式化来说每个盒子的<code>margin-left</code>与包含块容器的<code>border-left</code>相接触，对于从右往左的格式化刚好相反。即使存在浮动也是如此。</li></ul><p><strong>如何触发BFC</strong></p><ul><li>根元素<code>html</code></li><li><code>overflow</code>不为<code>visible</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>float</code>不为`none</li><li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>,<code>inline-block</code> 中任何一个</li><li><code>display</code>为<code>table</code>、<code>table-row</code>、<code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是HTML <code>table</code>、<code>row</code>、<code>tbody</code>、<code>thead</code>、<code>tfoot</code>的默认属性）或 <code>inline-table</code>）</li><li><code>display</code>为<code>flow-root</code>的元素</li><li><code>contain</code>值为<code>layout</code>、<code>content</code>或<code>paint</code>的元素</li><li><code>display</code>为<code>flex</code>或<code>inline-flex</code>元素的直接子元素</li><li><code>display</code>为<code>grid</code>或<code>inline-grid</code>元素的直接子元素</li><li>元素的<code>column-count</code>或<code>column-width</code>不为<code>auto</code>，包括<code>column-count</code>为 <strong>1</strong></li><li><code>column-span</code>为<code>all</code>的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51" target="_blank" rel="noopener">标准变更</a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362" target="_blank" rel="noopener">Chrome bug</a>）。</li></ul><p><strong>BFC用处</strong></p><ul><li>清除浮动</li><li>防止<code>margin</code>重叠(其实这里我觉得不用相邻的<code>margin</code>就可以了。。)</li><li>两栏自适应布局</li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>BFC的内容其实不多，规则看起来也比较拗口，但是BFC本身其实我们一直都在使用。希望以后的某天回忆BFC的时候我还能清晰记住BFC的规则<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;今天在题目里看到了BFC的提问，虽然之前对于BFC有粗浅的了解过。但是到目前为止已经比较久远了，对BFC的记忆已经不是很清楚了。只记得BFC的触发方法以及
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="BFC" scheme="https://xzh97.github.io/tags/BFC/"/>
    
      <category term="CSS3" scheme="https://xzh97.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS总结</title>
    <link href="https://xzh97.github.io/2019/12/15/css-summary/"/>
    <id>https://xzh97.github.io/2019/12/15/css-summary/</id>
    <published>2019-12-15T13:35:25.000Z</published>
    <updated>2020-07-22T14:52:13.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>在前几天的面试题中，碰到了一些css的问题。发现自己虽然可以答出大部分的东西，但是还是有一些不太常见的地方说的不准确。</p><h2 id="CSS"><a class="header-anchor" href="#CSS"></a>CSS</h2><p>CSS就是指层叠样式表(Cascading Style Sheets)，主要是用来定义如何显示HTML文档。是页面更加好看，美观。</p><h2 id="选择器"><a class="header-anchor" href="#选择器"></a>选择器</h2><p>选择器就是用来通过某些条件来选择与CSS规则相匹配的HTML元素。<br>选择器主要有以下这些</p><ul><li>通配符（*）：通配符会匹配HTML文档的所有元素</li><li>元素选择器：例：<code>body{}</code>选择HTML文档中的<code>body</code>元素</li><li>类选择器：例：<code>.wrapper{}</code>选择HTML文档中<code>class</code>属性为<code>wrapper</code>的元素</li><li>id选择器：例：<code>#root</code>选择HTML文档中<code>id</code>属性为<code>root</code>的元素</li><li>后代选择器：例：<code>body .wrapper{}</code>选择<code>body</code>元素中的子元素类名为<code>wrapper</code>的元素</li><li>相邻元素选择器：例：<code>div + p{}</code>与<code>div</code>相邻的<code>p</code>元素（ps：<code>div</code>和<code>p</code>有同一个父级）</li><li>属性选择器：例：<code>input[type='text']{}</code>选择<code>input</code>中<code>type</code>为<code>text</code>的元素</li><li>伪类选择器：例：<code>div:hover{ cursor:'pointer'}</code>会在鼠标滑过<code>div</code>时把鼠标变成一个小手</li></ul><h2 id="优先级"><a class="header-anchor" href="#优先级"></a>优先级</h2><p>对于选择器来说，是会有优先级的。主要指浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。<br><strong>优先级的计算方式：!important &gt; 内联 &gt; id选择器(#) &gt; 类选择器(.) &gt; 元素选择器</strong></p><h2 id="继承"><a class="header-anchor" href="#继承"></a>继承</h2><p>html元素可以从父元素那里继承一部分css属性，即使当前元素没有定义该属性。这样可以少重复定义很多的属性。</p><ul><li>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</li><li>所有元素可继承：visibility和cursor。</li><li>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</li><li>终端块状元素可继承：text-indent和text-align。</li><li>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。</li><li>表格元素可继承：border-collapse。</li></ul><h2 id="CSS3"><a class="header-anchor" href="#CSS3"></a>CSS3</h2><p>CSS3其实也没有什么很多东西，主要就是对于CSS的一些补充和加强。</p><ul><li>font-face 可以设置字体集</li><li>@media 媒体查询，可以设置元素在不同分辨率下的css</li><li>transform 对元素进行2d、3d转换实现对元素的移动、缩放、转动、拉长或拉伸。</li><li>transition 过渡 元素从一种样式逐渐改变为另一种的效果。</li><li>border-radius 边框圆角 是边框可以有圆角</li><li>box-shadow 边框阴影</li><li>box-sizing 盒子模型 设置width和height是否包括内边距（padding）和外边距（margin）<ul><li>border-box：设置的 width/height = width/height + margin + padding</li><li>content-box：设置的width/height = width/height</li></ul></li><li>animation，@keyframes 动画</li><li>flex 弹性布局模式 使布局更加舒服</li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>css虽然平时用起来其实并不难，可实际上还是有很多的知识点需要学习。毕竟世界不是一成不变的。很多时候都需要发展才能更好的满足开发需要。哦对了,这里强烈推荐<a href="https://www.zhangxinxu.com/" target="_blank" rel="noopener">张鑫旭</a>的博客网站。他对于css的理解真的非常深，网站有很多好文，看了让人受益良多。<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;在前几天的面试题中，碰到了一些css的问题。发现自己虽然可以答出大部分的东西，但是还是有一些不太常见的地方说的不准确。&lt;/p&gt;
&lt;h2 id=&quot;CSS&quot;&gt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://xzh97.github.io/tags/CSS/"/>
    
      <category term="选择器" scheme="https://xzh97.github.io/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
      <category term="优先级" scheme="https://xzh97.github.io/tags/%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
      <category term="CSS继承" scheme="https://xzh97.github.io/tags/CSS%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>web端的离线存储方式</title>
    <link href="https://xzh97.github.io/2019/12/15/offline-storage/"/>
    <id>https://xzh97.github.io/2019/12/15/offline-storage/</id>
    <published>2019-12-15T10:02:35.000Z</published>
    <updated>2020-09-27T14:33:53.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>讲道理，之前说过的一<s>天</s>月一篇其实是开玩笑的。莫名其妙就这么久没写过博客了。今天在回家的路上突然想起了这个问题----“从输入url到页面展示的过程有哪些？”。其实也不算突然吧，其实想想好像看面试题的时候经常会出现这么一道题目。今天就照着自己想到的东西来写这么一篇。</p><h2 id="过程"><a class="header-anchor" href="#过程"></a>过程</h2><ul><li>DNS解析输入的域名<ul><li>目的：解析域名获取ip</li><li>过程：<ol><li>浏览器缓存中查找是否有该域名对应的ip地址</li><li>操作系统缓存中查找是否有该域名对应的ip地址</li><li>向本地域名服务器来请求解析</li><li>向上一级域名服务器请求解析</li><li>重复4步骤，一直到根服务器为止</li><li>返回解析出的结果，并且缓存到本地域名服务器以及操作系统缓存中</li></ol></li></ul></li><li>向服务端发出TCP连接<ul><li>目的：获取稳定可靠的连接</li><li>TCP三次握手过程：<ol><li>客户端向服务端发出一个数据包</li><li>服务端接收到客户端发送的数据包并打上确认的标记，然后返回给客户端</li><li>客户端接收到数据包，加上确认标记。再次发送给服务端。</li><li>建立连接</li></ol></li><li>TCP四次挥手过程：<ol><li>客户端向服务端发出一个数据包。此时客户端进入<code>FIN-WAIT-1</code>（终止等待1）阶段</li><li>服务端接收到数据包然后返回一个确认数据包给客户端。此时服务端进入<code>CLOSE-WAIT</code>（半关闭阶段），客户端接收到报文之后进入<code>FIN-WAIT-2</code>（终止等待2）阶段</li><li>服务端向客户端发出一个数据包（连接释放报文）。此时服务端进入<code>LAST-ACK</code>（最后确认阶段）</li><li>客户端向服务端发出一个数据包（确认报文）。此时客户端进入<code>TIME-WAIT</code>（时间等待）阶段。在过了<code>2MSL</code>(MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间)。之后客户端进入<code>CLOSED</code>阶段，服务端接收到客户端的确认报文之后立马进入<code>CLOSED</code>阶段。</li></ol></li></ul></li><li>web端发送请求，服务端返回资源给客户端。</li><li>web端解析并渲染资源（正常结构）<ul><li>知识点：web端如何渲染</li><li>渲染过程：<ol><li>解析HTML文档构建DOM树，</li><li>解析CSS构建CSSOM</li><li>DOM树和CSSOM合并成一个节点树</li><li>浏览器通过节点树计算节点在页面所处的位置</li><li>浏览器渲染节点</li></ol></li><li>其它知识：<ol><li><code>script</code>的加载/执行默认都是会阻塞渲染流程的，除非加了<code>defer</code>(异步加载，延迟按序执行)/<code>async</code>（异步加载，加载完执行）。但是在实际中，加了<code>defer</code>的<code>script</code>脚本也未必会真的按照顺序延迟执行。</li><li><strong>DOM树和CSSOM的渲染是会阻塞的，之前认为的不阻塞其实指的是CSS的解析不会影响到DOM的解析，而渲染是会阻止的</strong></li><li>重绘：节点的视觉属性发生变化，例如<code>color</code>,<code>font</code>等的变化，引起的浏览器重新绘制节点的行为。</li><li>回流：节点的位置属性发生变化，例如<code>left,top,right,bottom,display:none,width,height</code>等的变化，引起的浏览器重新计算节点位置并绘制节点的行为</li><li>重绘和回流的关系： 重绘不一定回流，回流必然会引起重绘</li><li>优化：<ul><li>尽量避免直接操作DOM节点</li><li>可以使用<code>position</code>把一些复杂动画的节点脱离文档流。从而避免其父元素及周围元素发生变化从而引起回流</li></ul></li></ol></li></ul></li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>从url输入到页面展示的过程其实大致可分成两部分，一部分是请求，一部分是渲染的部分。请求部分主要又分为dns解析，以及建立/释放tcp连接。渲染部分主要是渲染的步骤。这篇文章其实还可以更细致一些，比如可以讲讲DNS，TCP的具体的东西。之后有空再写把</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;讲道理，之前说过的一&lt;s&gt;天&lt;/s&gt;月一篇其实是开玩笑的。莫名其妙就这么久没写过博客了。今天在回家的路上突然想起了这个问题----“从输入url到页面展示
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML5" scheme="https://xzh97.github.io/tags/HTML5/"/>
    
      <category term="cache" scheme="https://xzh97.github.io/tags/cache/"/>
    
      <category term="web" scheme="https://xzh97.github.io/tags/web/"/>
    
      <category term="离线存储" scheme="https://xzh97.github.io/tags/%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
