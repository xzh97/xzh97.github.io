<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追梦的蚂蚁</title>
  
  <subtitle>何须仰望他人，自己亦是风景</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xzh97.github.io/"/>
  <updated>2020-07-30T14:10:22.365Z</updated>
  <id>https://xzh97.github.io/</id>
  
  <author>
    <name>xzh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组件设计思考-CustomTransfer</title>
    <link href="https://xzh97.github.io/2020/07/22/component-design-custom-transfer/"/>
    <id>https://xzh97.github.io/2020/07/22/component-design-custom-transfer/</id>
    <published>2020-07-22T14:45:59.000Z</published>
    <updated>2020-07-30T14:10:22.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件设计"><a class="header-anchor" href="#组件设计"></a>组件设计</h2><h3 id="前言"><a class="header-anchor" href="#前言"></a>前言</h3><p>本来之前部门那边有这样类似的框，我还以为这个组件是通用组件，结果发现并不是。而且选择部门那块代码业务代码实在太多。所以此次需求里，我准备写个通用组件。</p><h3 id="设计"><a class="header-anchor" href="#设计"></a>设计</h3><h4 id="设计图"><a class="header-anchor" href="#设计图"></a>设计图</h4><p><img src="http://122.51.73.210:3000/upload/2020-07-22/202007224899.jpg" alt="image"></p><h4 id="数据格式"><a class="header-anchor" href="#数据格式"></a>数据格式</h4><p>把外部传入数据转换成组件内部的通用格式</p><h3 id="组件实例之CustomTransfer组件设计"><a class="header-anchor" href="#组件实例之CustomTransfer组件设计"></a>组件实例之CustomTransfer组件设计</h3><h4 id="设计思路"><a class="header-anchor" href="#设计思路"></a>设计思路</h4><h5 id="布局"><a class="header-anchor" href="#布局"></a>布局</h5><p><img src="http://122.51.73.210:3000/upload/2020-07-22/20200722319.png" alt="image"></p><h5 id="数据处理"><a class="header-anchor" href="#数据处理"></a>数据处理</h5><ul><li>通用数据格式:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    key: &#39;&#39;,  &#x2F;&#x2F; 索引，做diff用</span><br><span class="line">    value: &#39;&#39;, &#x2F;&#x2F; 变量value</span><br><span class="line">    label: &#39;&#39;, &#x2F;&#x2F; 变量名称</span><br><span class="line">    type: &#39;&#39;, &#x2F;&#x2F; 变量类型</span><br><span class="line">    children:[] &#x2F;&#x2F; 变量子级数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据获取方式<ul><li>外部传入<code>dataSource</code></li><li>外部传入<code>method, getUrl, extraParams, searchKey</code></li></ul></li><li>数据转换方式：<ul><li>传入<code>labelKey，valueKey，childKey，typeKey</code>然后通过<code>formater</code>转换数据格式。</li></ul></li></ul><h4 id="交互"><a class="header-anchor" href="#交互"></a>交互</h4><ul><li>未弹框显示一个<code>multiple</code>模式的<code>select</code>控件</li><li>点击<code>Select</code> 出现<code>Modal</code>弹框</li><li>左上<code>Input</code>可以实时模糊查询</li><li>搜索出的列表展示在左下方，点击列表<code>item</code>来选择控件，若传入<code>typeCheck</code>，则点击时对选择做类型校验</li><li>已选择的列表展示在右下方，可以点击右侧X样式的<code>icon</code>删除</li><li>点击取消 不保存已选择控件列表</li><li>点击确定，保存已选择控件列表</li></ul><h3 id="优点"><a class="header-anchor" href="#优点"></a>优点</h3><ul><li>布局清晰，各模块功能思路清楚，可读性好。</li><li>在外部加载数据传入组件内，由于组件在外部可能并发使用较多，为了避免同时调用此接口</li></ul><h3 id="不足"><a class="header-anchor" href="#不足"></a>不足</h3><ul><li>传入的<code>typeCheck</code>和<code>isError</code>属性，这里并不符合我的预期。因为这里是业务的需求，而不是组件本身的需求。但由于外部页面布局未使用<code>FormItem</code>包裹，不好做处理保存的报错提示处理。</li><li>暂时没有对外暴露出<code>onSearch</code>，因为业务上需求是在查询后默认展开所有树节点</li><li>组件设计仍然待改进</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件设计&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#组件设计&quot;&gt;&lt;/a&gt;组件设计&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;
&lt;p&gt;本来之前部门那边有这样
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="组件" scheme="https://xzh97.github.io/tags/%E7%BB%84%E4%BB%B6/"/>
    
      <category term="react" scheme="https://xzh97.github.io/tags/react/"/>
    
      <category term="javascript" scheme="https://xzh97.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码学习（一）：响应式-1</title>
    <link href="https://xzh97.github.io/2020/05/12/vue-reactivty/"/>
    <id>https://xzh97.github.io/2020/05/12/vue-reactivty/</id>
    <published>2020-05-12T04:39:34.000Z</published>
    <updated>2020-07-22T14:48:11.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="header-anchor" href="#前言"></a>前言</h3><p>首先声明一下，本来计划是一月一篇，三月加了一整个月的班，9107的这种，真挺累的。所以四月份就没有写了，而且最近觉得有道云笔记挺好用，所以很多东西都先在有道云里写了。就看后面啥时候有空贴出来。好了，步入正题。其实在这之前呢，就陆陆续续的阅读过<code>vue2</code>的源码，但是看的都零零散散的，这次决定来系统的解读下<code>vue2</code>的源码，希望自己能对<code>vue2</code>掌握的更加深刻以及提升自己的水平。这篇文章主要解读一下<code>vue2</code>的响应式原理，why？ 因为这个问题实在是太常见了。😜</p><h3 id="过程图"><a class="header-anchor" href="#过程图"></a>过程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">有道云笔记的过程图实在太丑了，我之后用其他的软件画一个QWQ</span><br><span class="line">&lt;!--graph TD</span><br><span class="line">    A[data&#x2F;props]</span><br><span class="line">    A --&gt; B(defineReactive)</span><br><span class="line">    B --&gt; |tracking| D[依赖收集]</span><br><span class="line">    B --&gt; |trigger| E[触发]</span><br><span class="line">    D --&gt; |depend| F[Dep]</span><br><span class="line">    E --&gt; |notify| F[Dep]</span><br><span class="line">    </span><br><span class="line">    G[computed]</span><br><span class="line">    G --&gt; H(computedWatcher)</span><br><span class="line">    H --&gt; |tracking| I[依赖收集]</span><br><span class="line">    H --&gt; |trigger| J[依赖收集]</span><br><span class="line">    I --&gt; |depend| F[Dep]</span><br><span class="line">    J --&gt; |notify| F[Dep]</span><br><span class="line">    </span><br><span class="line">    K[watch]</span><br><span class="line">    K --&gt; L(Watcher)</span><br><span class="line">    L --&gt; |update| F[Dep]</span><br><span class="line">    L --&gt; |addDep| F[Dep]</span><br><span class="line">    L --&gt; |run| M(callback)</span><br><span class="line">    </span><br><span class="line">    N[$mount]</span><br><span class="line">    N --&gt; O(render watcher)</span><br><span class="line">    N --&gt; P(updateComponent)</span><br><span class="line">    N --&gt; |update| F[Dep]</span><br><span class="line">    N --&gt; |addDep| F[Dep]--&gt;</span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a class="header-anchor" href="#Object-defineProperty"></a>Object.defineProperty</h3><blockquote><p>Object.defineProperty()，它会在一个对象上定义一个新属性，或者修改一个对象的现有属性并返回此对象</p></blockquote><p>vue的响应式主要是通过<code>Object.defineProperty()</code>来完成的。但由于<code>Object.defineProperty()</code>是<code>ES5</code>的内容，所以<code>vue</code>本身兼容不了<code>ie8</code>。这里大致说明一下<code>Object.defineProperty()</code>的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zh'</span>,</span><br><span class="line">  age: <span class="string">'23'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的赋值等价于</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">'name'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'zh'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">'age'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>, <span class="comment">// 是否可枚举</span></span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">// 是否可以被改变以及被删除</span></span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">// 是否可以被赋值</span></span><br><span class="line">    value: <span class="number">23</span> <span class="comment">// 赋值， 不写value 默认赋值undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// enumerable，configurable，writable，value被称为数据描述符，</span></span><br><span class="line"><span class="comment">// enumerable，configurable，get(),set()被称为存取描述符。</span></span><br><span class="line"><span class="comment">//enumerable，configurable同时是两种描述符，数据描述符和存取描述符不能同时存在，同时存在时会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">    <span class="comment">// 是一个给key提供的getter方法，当我们 访问 该key值的时候会被触发</span></span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`get<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是一个给key提供的setter方法，当我们 改变 该key值的时候会被触发</span></span><br><span class="line">    <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`set变化，<span class="subst">$&#123;key&#125;</span>的newVal是<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);</span><br><span class="line">obj.name = <span class="string">'zh1'</span>;</span><br></pre></td></tr></table></figure><p>当我们给<code>obj</code>设置好了<code>get</code>和<code>set</code>之后，我们就可以简单的把这个对象称为是一个响应式对象。那么，<code>vue</code>中的响应式对象究竟是怎么样的呢？</p><h3 id="响应式对象入口"><a class="header-anchor" href="#响应式对象入口"></a>响应式对象入口</h3><p>想了解响应式，我们先看下<code>vue</code>的初始化过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue的最初入口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options) </span><br><span class="line">  <span class="comment">// 我们可以看到vue调用时其实就调用了一个_init方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义了_init方法</span></span><br><span class="line">initMixin(Vue)</span><br><span class="line"><span class="comment">// 添加数据相关处理方法，$set,$delete,$watch</span></span><br><span class="line">stateMixin(Vue)  </span><br><span class="line"><span class="comment">// 添加事件方法，$on,$once,$off,$emit</span></span><br><span class="line">eventsMixin(Vue)</span><br><span class="line"><span class="comment">// 添加生命周期方法， _update,$forceUpdate,$destory</span></span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line"><span class="comment">// 添加渲染相关处理 $nextTick, _render</span></span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// _init方法内容</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm) <span class="comment">// 初始化生命周期相关</span></span><br><span class="line">    initEvents(vm) <span class="comment">// 初始化事件中心相关</span></span><br><span class="line">    initRender(vm) <span class="comment">// 初始化渲染相关</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>) </span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="comment">// 数据初始化，响应式原理 start</span></span><br><span class="line">    initState(vm) <span class="comment">// 可以看到这里是我们的目标</span></span><br><span class="line">    <span class="comment">// 数据初始化，响应式原理 end</span></span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// initState 数据初始化。根据你传入的options的内容决定需要跑哪些对应的数据初始化方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="comment">// 在这里的初始化其实没有啥特别的东西，主要逻辑如下：</span></span><br><span class="line">  <span class="comment">// 1. 数据是否重复声明</span></span><br><span class="line">  <span class="comment">// 2. 通过proxy处理数据，使得我们可以通过this.xx来访问数据</span></span><br><span class="line">  <span class="comment">// 3. 对传入的数据做响应式处理</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化传入的data数据。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// data为什么是以方法传入的？</span></span><br><span class="line">  <span class="comment">// vue实例可能是组件。而对于组件来说，每个组件的data应该是独立存在的，不能互相影响。 </span></span><br><span class="line">  <span class="comment">// 所以说data为什么推荐的是传入function</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="comment">// 防止重复变量声明</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">    <span class="comment">// 代理方法</span></span><br><span class="line">    <span class="comment">// 我们的this.xx属性实际是访问的this._data.xx</span></span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 重点地方， 响应式处理的方法</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="observe"><a class="header-anchor" href="#observe"></a>observe</h3><p><code>observe</code>定义在<code>core/instance/observer.js</code>中。我们看下<code>observe</code>里做了哪些事情。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否是对象以及是否为v-dom</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">  <span class="comment">// 缓存处理</span></span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">  <span class="comment">// 实例化一个Observer类</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>observe()</code>主要是对传入的<code>value</code>做了是否缓存过的判断，然后返回的仍然是一个<code>Observer</code>实例对象。接下来我们看一下<code>Observer</code>里做了什么处理</p><h3 id="Observer"><a class="header-anchor" href="#Observer"></a>Observer</h3><p>Observer的定义和observe方法在同一个文件中，我们可以看到<code>Observer</code>是一个类。我们看下这个类中做了哪些处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line">  vmCount: number; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value <span class="comment">// 传入值</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep() <span class="comment">// 声明Dep类</span></span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 绑定Observer实例到value的__ob__属性上</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>) </span><br><span class="line">    <span class="comment">// todo 看代码注释说是拦截，然后加强对array的处理。具体需要看后面是怎么用的。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对对象做一个声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj: Object, key: string, val: any, enumerable?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以知道，<code>Observer</code>类就是给传入的<code>object/array</code>设置<code>getter</code>和<code>setter</code>，并没有做什么太多的处理，就是声明了一个<code>Dep</code>类。然后把自身实例设置到<code>value</code>的<code>__ob__</code>属性上，最后就是对对象和数组的差异化处理。</p><h3 id="defineReactive"><a class="header-anchor" href="#defineReactive"></a>defineReactive</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这才是真正声明一个响应式对象的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 判断是否可以改变obj的值</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      <span class="comment">// 触发更新</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以知道，<code>defineReactive()</code>主要是通过<code>Object.defineProperty()</code>对<code>obj</code>设置<code>getter</code>和<code>setter</code>。并且还对<code>childObj</code>进行了<code>observe</code>操作，这样就能保证不管<code>obj</code>的结构多复杂，都能够把子属性变成响应式对象并能在访问或修改时及时的触发<code>getter</code>或<code>setter</code>。最后，我们在<code>getter</code>中进行依赖收集的操作，在<code>setter</code>中触发更新的操作。</p><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><p><code>vue</code>的响应式核心就是通过<code>Object.defineProperty()</code>来对传入对象添加<code>getter</code>和<code>setter</code>。由于篇幅已经挺长的了，之后的依赖收集和触发更新放到下一篇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;
&lt;p&gt;首先声明一下，本来计划是一月一篇，三月加了一整个月的班，9107的这种，真挺累的。所以四月份就没有写了，而且最近觉得有道云笔记挺好用，所以很多东西都先在有
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://xzh97.github.io/tags/vue/"/>
    
      <category term="源码" scheme="https://xzh97.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="响应式" scheme="https://xzh97.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Webpack学习笔记（一）</title>
    <link href="https://xzh97.github.io/2020/02/10/learn-webpack/"/>
    <id>https://xzh97.github.io/2020/02/10/learn-webpack/</id>
    <published>2020-02-10T03:51:23.000Z</published>
    <updated>2020-03-22T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>2020魔幻开年，感觉今年问题更多。 当然这跟我今天的主题并没有啥关系哈哈哈。学习还是要学的，毕竟我馋<code>webpack</code>已经很久了😜。</p><h2 id="概念"><a class="header-anchor" href="#概念"></a>概念</h2><p>Webpack是一个前端资源加载/打包工具，前端工程化主要就是靠这些打包工具来体现</p><h2 id="Webpack基础配置"><a class="header-anchor" href="#Webpack基础配置"></a>Webpack基础配置</h2><ul><li>入口(entry): 用来配置入口文件，告诉<code>webpack</code>应该从哪里开始打包</li><li>输出(output): 配置最终打包生成的目录，通常为<code>dist</code></li></ul><h2 id="loaders"><a class="header-anchor" href="#loaders"></a>loaders</h2><p>这里就简单写一些常用的loader的作用</p><ul><li><code>css-loader</code>: 解析<code>css</code>文件</li><li><code>style-loader</code>: 把解析好的<code>css</code>用<code>style</code>标签显示出来</li><li><code>babel-loader</code>: 把<code>es6</code>及之后的语法解析成<code>es5</code>语法，最大的作用就是兼容浏览器。</li><li><code>url-loader</code>,<code>file-loader</code>: <code>webpack</code>加载图片, <code>url-loader</code>更像是<code>file-loader</code>的增强版。当设置<code>limit</code>时，超出此范围则用<code>file-loader</code>解析，小于则返回<code>base64</code>格式。</li><li><code>raw-loader</code>: 读取文件内的内容，并作为字符串返回</li><li><code>sass-loader</code>,<code>less-loader</code>: css预编译文件解析。但是!!用的时候要记得：<strong><code>css-loader</code>和<code>style-loader</code>一起用且顺序排列有要求，从右往左依次调用。即：<code>['style-loader','css-loader','sass-loader/less-loader']</code></strong></li><li><code>vue-loader</code>: 解析<code>.vue</code>文件</li></ul><h2 id="plugins"><a class="header-anchor" href="#plugins"></a>plugins</h2><ul><li><code>html-webpack-plugin</code>:<ul><li>为<code>html</code>文件引入外部资源如<code>script</code>，<code>link</code>动态添加每次<code>compile</code>后的<code>hash</code>，防止引用的缓存问题。</li><li>可以生成创建html入口文件。</li></ul></li><li><code>clean-webpack-plugin</code>:<ul><li>清理dist文件</li></ul></li></ul><h2 id="感言"><a class="header-anchor" href="#感言"></a>感言</h2><p>看了一下webpack的官网，发现还要好多好东西要学。最近加班很严重，感觉很累。学习的兴趣都减少了好多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;2020魔幻开年，感觉今年问题更多。 当然这跟我今天的主题并没有啥关系哈哈哈。学习还是要学的，毕竟我馋&lt;code&gt;webpack&lt;/code&gt;已经很久了�
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://xzh97.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面展示的过程</title>
    <link href="https://xzh97.github.io/2020/01/15/url-parse/"/>
    <id>https://xzh97.github.io/2020/01/15/url-parse/</id>
    <published>2020-01-15T12:56:57.000Z</published>
    <updated>2020-07-22T14:49:49.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>讲道理，之前说过的一<s>天</s>月一篇其实是开玩笑的。莫名其妙就这么久没写过博客了。今天在回家的路上突然想起了这个问题----“从输入url到页面展示的过程有哪些？”。其实也不算突然吧，其实想想好像看面试题的时候经常会出现这么一道题目。今天就照着自己想到的东西来写这么一篇。</p><h2 id="过程"><a class="header-anchor" href="#过程"></a>过程</h2><ul><li>DNS解析输入的域名<ul><li>目的：解析域名获取ip</li><li>过程：<ol><li>浏览器缓存中查找是否有该域名对应的ip地址</li><li>操作系统缓存中查找是否有该域名对应的ip地址</li><li>向本地域名服务器来请求解析</li><li>向上一级域名服务器请求解析</li><li>重复4步骤，一直到根服务器为止</li><li>返回解析出的结果，并且缓存到本地域名服务器以及操作系统缓存中</li></ol></li></ul></li><li>向服务端发出TCP连接<ul><li>目的：获取稳定可靠的连接</li><li>TCP三次握手过程：<ol><li>客户端向服务端发出一个数据包</li><li>服务端接收到客户端发送的数据包并打上确认的标记，然后返回给客户端</li><li>客户端接收到数据包，加上确认标记。再次发送给服务端。</li><li>建立连接</li></ol></li></ul></li><li>web端发送请求，服务端返回资源给客户端。</li><li>web端解析并渲染资源（正常结构）<ul><li>知识点：web端如何渲染</li><li>渲染过程：<ol><li>解析HTML文档构建DOM树，解析CSS构建CSSOM</li><li>DOM树和CSSOM合并成一个节点树</li><li>浏览器通过节点树计算节点在页面所处的位置</li><li>浏览器渲染节点</li></ol></li><li>其它知识：<ol><li>重绘：节点的视觉属性发生变化，例如<code>color</code>,<code>font</code>等的变化，引起的浏览器重新绘制节点的行为。</li><li>回流：节点的位置属性发生变化，例如<code>left,top,right,bottom,display:none,width,height</code>等的变化，引起的浏览器重新计算节点位置并绘制节点的行为</li><li>重绘和回流的关系： 重绘不一定回流，回流必然会引起重绘</li><li>优化：<ul><li>尽量避免直接操作DOM节点</li><li>可以使用<code>position</code>把一些复杂动画的节点脱离文档流。从而避免其父元素及周围元素发生变化从而引起回流</li></ul></li></ol></li></ul></li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>以上就是对url输入到页面展示的过程的一些知识的理解和总结。其实还可以再往细来讲，不过由于自己知识水平有限，对于网络协议以及数据包结构的理解不深，想了想还是不丢人现眼了哈哈哈。<br>That’s all!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;讲道理，之前说过的一&lt;s&gt;天&lt;/s&gt;月一篇其实是开玩笑的。莫名其妙就这么久没写过博客了。今天在回家的路上突然想起了这个问题----“从输入url到页面展示
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://xzh97.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="https://xzh97.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>hexo添加gitalk作为博客评论系统</title>
    <link href="https://xzh97.github.io/2019/12/18/hexo-add-gitalk/"/>
    <id>https://xzh97.github.io/2019/12/18/hexo-add-gitalk/</id>
    <published>2019-12-18T14:55:05.000Z</published>
    <updated>2020-07-22T14:49:58.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>莫得评论的博客莫得灵魂——<s>鲁迅</s>。</p><h2 id="Gitalk是什么"><a class="header-anchor" href="#Gitalk是什么"></a>Gitalk是什么</h2><p>Gitalk 一开始应该是<code>github</code>推出来配合搭建博客而做的评论插件。然而随着其他评论插件的没落，Gitalk 就火起来了。<br>它基于 <code>Github Issue</code> 和 <code>Preact</code> 开发。<br>除了支持 <code>Hexo</code> 外，还支持 <code>java</code>，<code>php</code> 等语言开发的博客。</p><h2 id="为啥用Gitalk"><a class="header-anchor" href="#为啥用Gitalk"></a>为啥用Gitalk</h2><p>之前其实还去看了其它的评论插件。一开始是打算用<code>duoshuo</code>或者<code>disqus</code>这两个插件其中一个（apollo主题自带）。然后:</p><ul><li><code>duoshuo</code>已经停止服务（还有网易云更贴）</li><li><code>disqus</code>的需要<s>科学上网</s></li><li>然后在寻找其它插件的时候碰巧看到了<code>Gitalk</code>，一定是特别的缘分。（其实是看到了<code>git</code>三个字眼）</li></ul><p><strong>搭建步骤</strong></p><ol><li>在github搭建一个仓库来存放评论(因为我的hexo博客是和githubPage绑定的，就不创建新的了。直接用的我的博客仓库)</li><li>把仓库Issue开启（这个好像是默认开启的，如果没改的话就不用动了）</li><li>注册申请一个<code>Github Application</code>(<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击此处可进入</a>)<br>创建好了之后，复制你的<code>ClientID，ClientSecret</code>。</li><li>在<code>hexo</code>主题下的<code>config.yml</code>文件加入这段：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#用来做启用判断可以不用，目前没有写相关逻辑</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="comment">#Github 用户名,</span></span><br><span class="line">    <span class="attr">repo:</span>  <span class="comment">#储存评论issue的github仓库名</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">[]</span> <span class="comment">#Github 用户名,</span></span><br><span class="line">    <span class="attr">oauth:</span></span><br><span class="line">        <span class="attr">clientID:</span>  <span class="comment">#`Github Application clientID`</span></span><br><span class="line">        <span class="attr">clientSecret:</span>  <span class="comment">#`Github Application clientSecret`</span></span><br></pre></td></tr></table></figure><ol start="5"><li>找到<code>hexo</code>主题内的评论模板<code>comment.jade</code>和头部模板<code>head.jade</code>，在里面新加以下代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 我提前把gitalk的css和js文件下载到本地了</span><br><span class="line">&#x2F;&#x2F; 同时其中的代码根据不同的模板也不一样，这里用的jade仅供参考</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; head</span><br><span class="line">if theme.gitalk.enable</span><br><span class="line">    link(rel&#x3D;&quot;stylesheet&quot;, href&#x3D;url_for(&quot;css&#x2F;gitalk.1.5.0.css&quot;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; comment</span><br><span class="line">if theme.gitalk.enable</span><br><span class="line">    #gitalk-container</span><br><span class="line">    script(src&#x3D;url_for(&quot;js&#x2F;gitalk.1.5.0.min.js&quot;))</span><br><span class="line">    script.</span><br><span class="line">        var params &#x3D; &#123;</span><br><span class="line">            clientID:&quot;#&#123;theme.gitalk.oauth.clientID&#125;&quot;,</span><br><span class="line">            clientSecret:&quot;#&#123;theme.gitalk.oauth.clientSecret&#125;&quot;,</span><br><span class="line">            repo:&quot;#&#123;theme.gitalk.repo&#125;&quot;,</span><br><span class="line">            admin:&quot;#&#123;theme.gitalk.admin&#125;&quot;,</span><br><span class="line">            id:window.location.pathname,</span><br><span class="line">            owner:&quot;#&#123;theme.gitalk.owner&#125;&quot;,</span><br><span class="line">            distractionFreeMode: false,</span><br><span class="line">        &#125;;</span><br><span class="line">        var gitalk &#x3D; new Gitalk(params)</span><br><span class="line">        gitalk.render(&#39;gitalk-container&#39;);</span><br></pre></td></tr></table></figure><p><strong>遇到的问题</strong><br>一开始，我发现在调用github的api时总是报错，返回状态码为:422。由于之前422我从来没有碰到过。于是我就去搜索了一下422的含义：<br><strong>422 Unprocessable Entity：请求格式正确，但是由于含有语义错误，无法响应。422 则表现为请求格式错误，但出现了 语义 错误，以至于服务端无法响应。可以理解为服务端能理解请求资源类型<code>content-type</code>，否则应该返回 415（Unsupported Media Type），也能理解请求实体内容，否则应该返回 400（Bad Request）。</strong><br>后面我根据接口去慢慢调试，发现是请求体中的<code>label=['Gitalk,location.pathname']</code>参数内包含了<code>location.pathname</code>导致的错误。其实这里我并没想传这个<code>location.pathname</code>,我传的应该是<code>pathname</code>的<code>value</code>才对。 然后我才发现，原来<code>config.yml</code>里面的内容其实都是<code>string</code>类型。于是把<code>params.id</code>写在了<code>comment.jade</code>里。最后成功解决了问题。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>所以说，平时还是要细心点才好。不过这波也不亏。学到了http状态码的知识。422（<strong>格式正确，语义有错误</strong>），415（<strong>不支持该请求资源类型</strong>）,400（<strong>请求实体内容有误。这个一般是请求体内的参数有问题</strong>）<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;莫得评论的博客莫得灵魂——&lt;s&gt;鲁迅&lt;/s&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Gitalk是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://xzh97.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xzh97.github.io/tags/hexo/"/>
    
      <category term="gitalk" scheme="https://xzh97.github.io/tags/gitalk/"/>
    
      <category term="apollo" scheme="https://xzh97.github.io/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>BFC总结</title>
    <link href="https://xzh97.github.io/2019/12/16/css-bfc/"/>
    <id>https://xzh97.github.io/2019/12/16/css-bfc/</id>
    <published>2019-12-16T14:04:16.000Z</published>
    <updated>2020-07-22T14:49:46.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>今天在题目里看到了BFC的提问，虽然之前对于BFC有粗浅的了解过。但是到目前为止已经比较久远了，对BFC的记忆已经不是很清楚了。只记得BFC的触发方法以及用户。所以今天写这篇文章来对之前的学习做一个总结。</p><p><strong>BFC是什么？</strong><br>BFC全称为块级格式上下文（Block Formatting Context）。是CSS的一种渲染机制。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p><strong>BFC规则</strong></p><ul><li>内部的盒子会在垂直方向，一个接一个的排列</li><li>盒子垂直方向的距离由<code>margin</code>来决定，属于同一个BFC的两个盒子，在相邻方向的外边距会发生重叠</li><li>BFC区域不会和<code>float</code>盒子区域重叠。</li><li>BFC就是页面上的一个隔离的独立容器， 容器内的子元素和BFC外面的元素互不影响.</li><li>对于从左往右的格式化来说每个盒子的<code>margin-left</code>与包含块容器的<code>border-left</code>相接触，对于从右往左的格式化刚好相反。即使存在浮动也是如此。</li></ul><p><strong>如何触发BFC</strong></p><ul><li>根元素<code>html</code></li><li><code>overflow</code>不为<code>visible</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>float</code>不为`none</li><li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>,<code>inline-block</code> 中任何一个</li><li><code>display</code>为<code>table</code>、<code>table-row</code>、<code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是HTML <code>table</code>、<code>row</code>、<code>tbody</code>、<code>thead</code>、<code>tfoot</code>的默认属性）或 <code>inline-table</code>）</li><li><code>display</code>为<code>flow-root</code>的元素</li><li><code>contain</code>值为<code>layout</code>、<code>content</code>或<code>paint</code>的元素</li><li><code>display</code>为<code>flex</code>或<code>inline-flex</code>元素的直接子元素</li><li><code>display</code>为<code>grid</code>或<code>inline-grid</code>元素的直接子元素</li><li>元素的<code>column-count</code>或<code>column-width</code>不为<code>auto</code>，包括<code>column-count</code>为 <strong>1</strong></li><li><code>column-span</code>为<code>all</code>的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51" target="_blank" rel="noopener">标准变更</a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362" target="_blank" rel="noopener">Chrome bug</a>）。</li></ul><p><strong>BFC用处</strong></p><ul><li>清除浮动</li><li>防止<code>margin</code>重叠(其实这里我觉得不用相邻的<code>margin</code>就可以了。。)</li><li>两栏自适应布局</li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>BFC的内容其实不多，规则看起来也比较拗口，但是BFC本身其实我们一直都在使用。希望以后的某天回忆BFC的时候我还能清晰记住BFC的规则<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;今天在题目里看到了BFC的提问，虽然之前对于BFC有粗浅的了解过。但是到目前为止已经比较久远了，对BFC的记忆已经不是很清楚了。只记得BFC的触发方法以及
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="BFC" scheme="https://xzh97.github.io/tags/BFC/"/>
    
      <category term="CSS3" scheme="https://xzh97.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS总结</title>
    <link href="https://xzh97.github.io/2019/12/15/css-summary/"/>
    <id>https://xzh97.github.io/2019/12/15/css-summary/</id>
    <published>2019-12-15T13:35:25.000Z</published>
    <updated>2020-07-22T14:52:13.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>在前几天的面试题中，碰到了一些css的问题。发现自己虽然可以答出大部分的东西，但是还是有一些不太常见的地方说的不准确。</p><h2 id="CSS"><a class="header-anchor" href="#CSS"></a>CSS</h2><p>CSS就是指层叠样式表(Cascading Style Sheets)，主要是用来定义如何显示HTML文档。是页面更加好看，美观。</p><h2 id="选择器"><a class="header-anchor" href="#选择器"></a>选择器</h2><p>选择器就是用来通过某些条件来选择与CSS规则相匹配的HTML元素。<br>选择器主要有以下这些</p><ul><li>通配符（*）：通配符会匹配HTML文档的所有元素</li><li>元素选择器：例：<code>body{}</code>选择HTML文档中的<code>body</code>元素</li><li>类选择器：例：<code>.wrapper{}</code>选择HTML文档中<code>class</code>属性为<code>wrapper</code>的元素</li><li>id选择器：例：<code>#root</code>选择HTML文档中<code>id</code>属性为<code>root</code>的元素</li><li>后代选择器：例：<code>body .wrapper{}</code>选择<code>body</code>元素中的子元素类名为<code>wrapper</code>的元素</li><li>相邻元素选择器：例：<code>div + p{}</code>与<code>div</code>相邻的<code>p</code>元素（ps：<code>div</code>和<code>p</code>有同一个父级）</li><li>属性选择器：例：<code>input[type='text']{}</code>选择<code>input</code>中<code>type</code>为<code>text</code>的元素</li><li>伪类选择器：例：<code>div:hover{ cursor:'pointer'}</code>会在鼠标滑过<code>div</code>时把鼠标变成一个小手</li></ul><h2 id="优先级"><a class="header-anchor" href="#优先级"></a>优先级</h2><p>对于选择器来说，是会有优先级的。主要指浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。<br><strong>优先级的计算方式：!important &gt; 内联 &gt; id选择器(#) &gt; 类选择器(.) &gt; 元素选择器</strong></p><h2 id="继承"><a class="header-anchor" href="#继承"></a>继承</h2><p>html元素可以从父元素那里继承一部分css属性，即使当前元素没有定义该属性。这样可以少重复定义很多的属性。</p><ul><li>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</li><li>所有元素可继承：visibility和cursor。</li><li>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</li><li>终端块状元素可继承：text-indent和text-align。</li><li>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。</li><li>表格元素可继承：border-collapse。</li></ul><h2 id="CSS3"><a class="header-anchor" href="#CSS3"></a>CSS3</h2><p>CSS3其实也没有什么很多东西，主要就是对于CSS的一些补充和加强。</p><ul><li>font-face 可以设置字体集</li><li>@media 媒体查询，可以设置元素在不同分辨率下的css</li><li>transform 对元素进行2d、3d转换实现对元素的移动、缩放、转动、拉长或拉伸。</li><li>transition 过渡 元素从一种样式逐渐改变为另一种的效果。</li><li>border-radius 边框圆角 是边框可以有圆角</li><li>box-shadow 边框阴影</li><li>box-sizing 盒子模型 设置width和height是否包括内边距（padding）和外边距（margin）<ul><li>border-box：设置的 width/height = width/height + margin + padding</li><li>content-box：设置的width/height = width/height</li></ul></li><li>animation，@keyframes 动画</li><li>flex 弹性布局模式 使布局更加舒服</li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>css虽然平时用起来其实并不难，可实际上还是有很多的知识点需要学习。毕竟世界不是一成不变的。很多时候都需要发展才能更好的满足开发需要。哦对了,这里强烈推荐<a href="https://www.zhangxinxu.com/" target="_blank" rel="noopener">张鑫旭</a>的博客网站。他对于css的理解真的非常深，网站有很多好文，看了让人受益良多。<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;在前几天的面试题中，碰到了一些css的问题。发现自己虽然可以答出大部分的东西，但是还是有一些不太常见的地方说的不准确。&lt;/p&gt;
&lt;h2 id=&quot;CSS&quot;&gt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://xzh97.github.io/tags/CSS/"/>
    
      <category term="选择器" scheme="https://xzh97.github.io/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
      <category term="优先级" scheme="https://xzh97.github.io/tags/%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
      <category term="CSS继承" scheme="https://xzh97.github.io/tags/CSS%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>web端的离线存储方式</title>
    <link href="https://xzh97.github.io/2019/12/15/offline-storage/"/>
    <id>https://xzh97.github.io/2019/12/15/offline-storage/</id>
    <published>2019-12-15T10:02:35.000Z</published>
    <updated>2020-07-22T14:52:24.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>昨天在学习的时候，看的问题里问HTML5的文件离线储存怎么使用，工作原理是什么？ 离线存储方式其实大概知道有这么些方式，还用过其中一些。但是要问原理的话其实还真的平时没去了解过。<br>所以今天来学习一下web端的几种离线存储方式。以后在项目里也可以尝试去使用这些特性。</p><h2 id="离线存储有以下几种方式"><a class="header-anchor" href="#离线存储有以下几种方式"></a>离线存储有以下几种方式</h2><ul><li>Application Cache</li><li>localStorage</li><li>sessionStorage</li><li>cookie</li><li>webSQL</li><li>indexedDB</li></ul><h2 id="Application-Cache"><a class="header-anchor" href="#Application-Cache"></a>Application Cache</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">Application Cache</a>目前已经被web标准废弃。这里不多讲，有兴趣的自行去了解一下吧。</p><h2 id="localStorage，sessionStorage（以下统称为storage）"><a class="header-anchor" href="#localStorage，sessionStorage（以下统称为storage）"></a>localStorage，sessionStorage（以下统称为storage）</h2><p><code>storage</code>都是H5新增的离线储存方式。<br><strong>浏览器兼容性</strong>：<code>IE8+，Chrome，Firefox，Safari，Opera</code><br><strong>存储方式</strong>：它们会以键值对的形式存储数据（需注意的是，存储的数据必须是字符串格式）<br><strong>优点</strong></p><ul><li>存储量大</li><li>浏览器原生支持</li><li>api简洁，使用方便</li><li>不需要和服务器交互</li></ul><p><strong>缺点</strong></p><ul><li>仍然会有浏览器兼容问题</li><li>安全性不是很好（别存敏感数据）</li></ul><p><strong>localStorage和sessionStorage的差别</strong></p><ul><li><code>localStorage</code>存储在浏览器本地，不会过期</li><li><code>sessionStorage</code>一旦当前页面会话关闭，数据就会删除</li></ul><p><strong>如何使用</strong></p><ul><li>存储：<code>storage.setItem(key,value)</code></li><li>获取：<code>storage.getItem(key,value)</code></li><li>删除：<code>storage.removeItem(key,value)</code>，当然啦 还可以按<code>F12</code>手动删除</li><li>删除所有：<code>storage.clear()</code></li></ul><h2 id="Cookie"><a class="header-anchor" href="#Cookie"></a>Cookie</h2><p>cookie是由后端服务器端创建保存在客服端一种数据库结构。浏览器请求和后端服务端响应都会携带创建的cookie来回传输。cookie在传输时存储在请求头和响应头中。<br><strong>原理</strong>：客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。<br><strong>版本</strong>：cookie有两个版本：version0和version1，它们两种设置响应头的标识，分别是“Set-Cookie”和“Set-Cookie2”。这两个版本的属性项有些不同。但是version1已经被废弃了。<br><strong>优点</strong></p><ul><li>拓展性和可用性都很好</li><li>不需要耗费服务器资源</li><li>简单</li><li>cookie生命周期可控</li></ul><p><strong>缺点</strong></p><ul><li>cookie数量和长度都有限制<ul><li>ie6及以下最多<strong>20</strong>个</li><li>ie7+，Firefox可以有<strong>50</strong>个</li><li>chrome和Safari没有限制</li><li>cookie的长度最多<strong>4k</strong>,大于4k会被截掉</li></ul></li><li>安全性：cookie有被截取篡改的风险</li><li>耗费资源：无论需不需要，都会加上cookie。</li></ul><p><strong>如何使用</strong><br>*添加<br>获取客户端的Cookie时，只能获取name与value属性，其它属性都不会被提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>,<span class="string">"xzh"</span>);<span class="comment">// 新建一个Cookie对象</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);                    <span class="comment">// 设置过期时间1天，以秒为单位</span></span><br><span class="line">response.addCookie(cookie);                    <span class="comment">// 保存cookie到客户端&#123;username:'xzh'&#125;</span></span><br></pre></td></tr></table></figure><p>*修改<br>只需要新建一个只有value不一样的同名cookie，然后添加到response中就可以覆盖掉原来的cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>,<span class="string">"xzh1"</span>);<span class="comment">// 新建一个Cookie对象</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);                    <span class="comment">// 设置过期时间1天，以秒为单位</span></span><br><span class="line">response.addCookie(cookie);                    <span class="comment">// 执行后就覆盖了原来的cookie&#123;username:'xzh1'&#125;</span></span><br></pre></td></tr></table></figure><p>*删除<br>只需要新建一个maxAge和value不一样的同名cookie，然后添加到response中就可以覆盖掉原来的cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>,<span class="string">"xzh"</span>);<span class="comment">// 新建一个Cookie对象</span></span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);                    <span class="comment">// 设置为0表示要删除</span></span><br><span class="line">response.addCookie(cookie);                    <span class="comment">// 执行后就从response里删除了</span></span><br></pre></td></tr></table></figure><h2 id="WebSQL"><a class="header-anchor" href="#WebSQL"></a>WebSQL</h2><p><a href="https://www.runoob.com/html/html5-web-sql.html" target="_blank" rel="noopener">Web SQL</a> 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。<br><strong>浏览器兼容性</strong>：Web SQL 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。<br><strong>核心方法</strong><br>以下是规范中定义的三个核心方法：</p><ul><li>openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。</li><li>transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。</li><li>executeSql：这个方法用于执行实际的 SQL 查询。</li></ul><p><strong>优点</strong></p><ul><li>本地的SQL</li><li>可以处理复杂数据</li></ul><p><strong>缺点</strong></p><ul><li>兼容性太差（光是这个就足以判死刑了。。。）</li></ul><p><strong>如何使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@desc </span>openDatabase参数说明 ，，，，</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>databaseName 数据库名称</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>version 版本号</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>description 描述文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>size 数据库大小</span></span><br><span class="line"><span class="comment"><span class="doctag">@param<span class="type">&#123;Function&#125;</span> </span>callback 创建回调</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//打开数据库</span></span><br><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建logs表，以及插入数据</span></span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'</span>);</span><br><span class="line">   tx.executeSql(<span class="string">'INSERT INTO LOGS (id, log) VALUES (1, "菜鸟教程")'</span>);</span><br><span class="line">   tx.executeSql(<span class="string">'INSERT INTO LOGS (id, log) VALUES (2, "www.runoob.com")'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">//查询记录</span></span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">'SELECT * FROM LOGS'</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">tx, results</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> len = results.rows.length, i;</span><br><span class="line">      msg = <span class="string">"&lt;p&gt;查询记录条数: "</span> + len + <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">'#status'</span>).innerHTML +=  msg;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">         alert(results.rows.item(i).log );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="IndexedDB"><a class="header-anchor" href="#IndexedDB"></a>IndexedDB</h2><p>用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索<br><strong>优点</strong></p><ul><li>标准化</li><li>存储复杂数据</li><li>支持索引</li></ul><p><strong>缺点</strong></p><ul><li>操作复杂</li><li>只适用于复杂数据（其实也是因为上一条 操作比较复杂，存储简单数据可以用但是没必要。）</li></ul><p><strong>如何使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开数据库，第一个参数为数据库名，第二个为数据库版本号</span></span><br><span class="line"><span class="keyword">var</span> dbRequest = <span class="built_in">window</span>.indexedDB.open(<span class="string">'testDb'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">dbRequest.onupgradeneeded=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建数据仓库</span></span><br><span class="line">    <span class="keyword">var</span> db=e.target.result;</span><br><span class="line">    <span class="keyword">if</span>(!db.objectStoreNames.contains(<span class="string">'users'</span>))&#123;</span><br><span class="line">        <span class="keyword">var</span> store=db.createObjectStore(<span class="string">'users'</span>,&#123;<span class="attr">keyPath</span>: <span class="string">'id'</span>&#125;);</span><br><span class="line">        store.createIndex(<span class="string">'nameIndex'</span>,<span class="string">'name'</span>,&#123;<span class="attr">unique</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        store.createIndex(<span class="string">'ageIndex'</span>,<span class="string">'age'</span>,&#123;<span class="attr">unique</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'upgrade successfully!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dbRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Open database successfully!'</span>);</span><br><span class="line">  <span class="comment">// 这里拿到了数据库</span></span><br><span class="line">  <span class="keyword">var</span> db = e.target.result;</span><br><span class="line">  <span class="keyword">var</span> storeName = <span class="string">'users'</span>;</span><br><span class="line">  <span class="comment">// 写入数据</span></span><br><span class="line">  <span class="keyword">var</span> tran = db.transaction(storeName, <span class="string">'readwrite'</span>);</span><br><span class="line">  <span class="keyword">var</span> users = tran.objectStore(storeName);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    users.add(&#123;</span><br><span class="line">      id: i,</span><br><span class="line">      name: <span class="string">'user'</span> + i,</span><br><span class="line">      age: <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">18</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询数据</span></span><br><span class="line">  <span class="keyword">var</span> userStore = db.transaction(storeName).objectStore(storeName);</span><br><span class="line">  <span class="keyword">var</span> request = userStore.openCursor();</span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cursor = e.target.result;</span><br><span class="line">    <span class="keyword">if</span>(cursor)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(cursor.key);</span><br><span class="line">      <span class="built_in">console</span>.log(cursor.value);</span><br><span class="line">      cursor.continue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>总之，前端用的最多的其实还是storage和cookie。 webSQL和indexedDB目前来说应用场景都比较少。所以后面两个只是大致了解了一下。 有兴趣的话，可以自己去mdn看看。说不定哪天也许就用到了。<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;昨天在学习的时候，看的问题里问HTML5的文件离线储存怎么使用，工作原理是什么？ 离线存储方式其实大概知道有这么些方式，还用过其中一些。但是要问原理的话其
      
    
    </summary>
    
    
      <category term="前端" scheme="https://xzh97.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML5" scheme="https://xzh97.github.io/tags/HTML5/"/>
    
      <category term="cache" scheme="https://xzh97.github.io/tags/cache/"/>
    
      <category term="web" scheme="https://xzh97.github.io/tags/web/"/>
    
      <category term="离线存储" scheme="https://xzh97.github.io/tags/%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
