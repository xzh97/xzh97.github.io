<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追梦的蚂蚁</title>
  
  <subtitle>何须仰望他人，自己亦是风景</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xzh97.github.io/"/>
  <updated>2020-01-09T14:30:42.703Z</updated>
  <id>https://xzh97.github.io/</id>
  
  <author>
    <name>xzh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo添加gitalk作为博客评论系统</title>
    <link href="https://xzh97.github.io/2019/12/18/hexo-add-gitalk/"/>
    <id>https://xzh97.github.io/2019/12/18/hexo-add-gitalk/</id>
    <published>2019-12-18T14:55:05.000Z</published>
    <updated>2020-01-09T14:30:42.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>莫得评论的博客莫得灵魂——<s>鲁迅</s>。</p><h2 id="Gitalk是什么"><a class="header-anchor" href="#Gitalk是什么"></a>Gitalk是什么</h2><p>Gitalk 一开始应该是<code>github</code>推出来配合搭建博客而做的评论插件。然而随着其他评论插件的没落，Gitalk 就火起来了。<br>它基于 <code>Github Issue</code> 和 <code>Preact</code> 开发。<br>除了支持 <code>Hexo</code> 外，还支持 <code>java</code>，<code>php</code> 等语言开发的博客。</p><h2 id="为啥用Gitalk"><a class="header-anchor" href="#为啥用Gitalk"></a>为啥用Gitalk</h2><p>之前其实还去看了其它的评论插件。一开始是打算用<code>duoshuo</code>或者<code>disqus</code>这两个插件其中一个（apollo主题自带）。然后:</p><ul><li><code>duoshuo</code>已经停止服务（还有网易云更贴）</li><li><code>disqus</code>的需要<s>科学上网</s></li><li>然后在寻找其它插件的时候碰巧看到了<code>Gitalk</code>，一定是特别的缘分。（其实是看到了<code>git</code>三个字眼）</li></ul><p><strong>搭建步骤</strong></p><ol><li>在github搭建一个仓库来存放评论(因为我的hexo博客是和githubPage绑定的，就不创建新的了。直接用的我的博客仓库)</li><li>把仓库Issue开启（这个好像是默认开启的，如果没改的话就不用动了）</li><li>注册申请一个<code>Github Application</code>(<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击此处可进入</a>)<br>创建好了之后，复制你的<code>ClientID，ClientSecret</code>。</li><li>在<code>apollo</code>主题的<code>config.yml</code>文件加入这段：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#用来做启用判断可以不用，目前没有写相关逻辑</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="comment">#Github 用户名,</span></span><br><span class="line">    <span class="attr">repo:</span>  <span class="comment">#储存评论issue的github仓库名</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">[]</span> <span class="comment">#Github 用户名,</span></span><br><span class="line">    <span class="attr">oauth:</span></span><br><span class="line">        <span class="attr">clientID:</span>  <span class="comment">#`Github Application clientID`</span></span><br><span class="line">        <span class="attr">clientSecret:</span>  <span class="comment">#`Github Application clientSecret`</span></span><br></pre></td></tr></table></figure><ol start="5"><li>找到<code>apollo</code>主题内的模板文件<code>comment.jade</code>模板和<code>head.jade</code>模板内加入以下代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 我提前把gitalk的css和js文件下载好了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; head</span><br><span class="line">if theme.gitalk.enable</span><br><span class="line">    link(rel&#x3D;&quot;stylesheet&quot;, href&#x3D;url_for(&quot;css&#x2F;gitalk.1.5.0.css&quot;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; comment</span><br><span class="line">if theme.gitalk.enable</span><br><span class="line">    #gitalk-container</span><br><span class="line">    script(src&#x3D;url_for(&quot;js&#x2F;gitalk.1.5.0.min.js&quot;))</span><br><span class="line">    script.</span><br><span class="line">        var params &#x3D; &#123;</span><br><span class="line">            clientID:&quot;#&#123;theme.gitalk.oauth.clientID&#125;&quot;,</span><br><span class="line">            clientSecret:&quot;#&#123;theme.gitalk.oauth.clientSecret&#125;&quot;,</span><br><span class="line">            repo:&quot;#&#123;theme.gitalk.repo&#125;&quot;,</span><br><span class="line">            admin:&quot;#&#123;theme.gitalk.admin&#125;&quot;,</span><br><span class="line">            id:window.location.pathname,</span><br><span class="line">            owner:&quot;#&#123;theme.gitalk.owner&#125;&quot;,</span><br><span class="line">            distractionFreeMode: false,</span><br><span class="line">        &#125;;</span><br><span class="line">        var gitalk &#x3D; new Gitalk(params)</span><br><span class="line">        gitalk.render(&#39;gitalk-container&#39;);</span><br></pre></td></tr></table></figure><p><strong>遇到的问题</strong><br>一开始，我发现在调用github的api时总是报错，还是报的422错误。讲道理，422状态码我以前从来没有碰到过。所以碰到了也是挺好奇的。之后我就去搜索了一下422状态码的含义：<br><strong>422 Unprocessable Entity：请求格式正确，但是由于含有语义错误，无法响应。422 则表现为请求格式错误，但出现了 语义 错误，以至于服务端无法响应。可以理解为服务端能理解请求资源类型<code>content-type</code>，否则应该返回 415（Unsupported Media Type），也能理解请求实体内容，否则应该返回 400（Bad Request）。</strong><br>后面我根据接口去慢慢调试，发现是请求体中的<code>label=['Gitalk,location.pathname']</code>参数内包含了<code>location.pathname</code>导致的错误。其实这里我并没想传这个<code>location.pathname</code>,我传的应该是<code>pathname</code>的<code>value</code>才对。 然后我才发现，原来<code>config.yml</code>里面的内容其实都是<code>string</code>类型。于是把<code>params.id</code>写在了<code>comment.jade</code>里。最后成功解决了问题。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>所以说，平时还是要细心点才好。不过这波也不亏。学到了http状态码的知识。422（<strong>格式正确，语义有错误</strong>），415（<strong>不支持该请求资源类型</strong>）,400（<strong>请求实体内容有误。这个一般是请求体内的参数有问题</strong>）<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;莫得评论的博客莫得灵魂——&lt;s&gt;鲁迅&lt;/s&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Gitalk是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://xzh97.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://xzh97.github.io/tags/hexo/"/>
    
      <category term="gitalk" scheme="https://xzh97.github.io/tags/gitalk/"/>
    
      <category term="apollo" scheme="https://xzh97.github.io/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>BFC总结</title>
    <link href="https://xzh97.github.io/2019/12/16/css-bfc/"/>
    <id>https://xzh97.github.io/2019/12/16/css-bfc/</id>
    <published>2019-12-16T14:04:16.000Z</published>
    <updated>2020-01-09T14:30:42.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>今天在题目里看到了BFC的提问，虽然之前对于BFC有粗浅的了解过。但是到目前为止已经比较久远了，对BFC的记忆已经不是很清楚了。只记得BFC的触发方法以及用户。所以今天写这篇文章来对之前的学习做一个总结。</p><p><strong>BFC是什么？</strong><br>BFC全称为块级格式上下文（Block Formatting Context）。是CSS的一种渲染机制。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p><strong>BFC规则</strong></p><ul><li>内部的盒子会在垂直方向，一个接一个的排列</li><li>盒子垂直方向的距离由<code>margin</code>来决定，属于同一个BFC的两个盒子，在相邻方向的外边距会发生重叠</li><li>BFC区域不会和<code>float</code>盒子区域重叠。</li><li>BFC就是页面上的一个隔离的独立容器， 容器内的子元素和BFC外面的元素互不影响.</li><li>对于从左往右的格式化来说每个盒子的<code>margin-left</code>与包含块容器的<code>border-left</code>相接触，对于从右往左的格式化刚好相反。即使存在浮动也是如此。</li></ul><p><strong>如何触发BFC</strong></p><ul><li>根元素<code>html</code></li><li><code>overflow</code>不为<code>visible</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>float</code>不为`none</li><li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>,<code>inline-block</code> 中任何一个</li><li><code>display</code>为<code>table</code>、<code>table-row</code>、<code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是HTML <code>table</code>、<code>row</code>、<code>tbody</code>、<code>thead</code>、<code>tfoot</code>的默认属性）或 <code>inline-table</code>）</li><li><code>display</code>为<code>flow-root</code>的元素</li><li><code>contain</code>值为<code>layout</code>、<code>content</code>或<code>paint</code>的元素</li><li><code>display</code>为<code>flex</code>或<code>inline-flex</code>元素的直接子元素</li><li><code>display</code>为<code>grid</code>或<code>inline-grid</code>元素的直接子元素</li><li>元素的<code>column-count</code>或<code>column-width</code>不为<code>auto</code>，包括<code>column-count</code>为 <strong>1</strong></li><li><code>column-span</code>为<code>all</code>的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51" target="_blank" rel="noopener">标准变更</a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362" target="_blank" rel="noopener">Chrome bug</a>）。</li></ul><p><strong>BFC用处</strong></p><ul><li>清除浮动</li><li>防止<code>margin</code>重叠(其实这里我觉得不用相邻的<code>margin</code>就可以了。。)</li><li>两栏自适应布局</li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>BFC的内容其实不多，规则看起来也比较拗口，但是BFC本身其实我们一直都在使用。希望以后的某天回忆BFC的时候我还能清晰记住BFC的规则<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;今天在题目里看到了BFC的提问，虽然之前对于BFC有粗浅的了解过。但是到目前为止已经比较久远了，对BFC的记忆已经不是很清楚了。只记得BFC的触发方法以及
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://xzh97.github.io/categories/CSS/"/>
    
    
      <category term="CSS3" scheme="https://xzh97.github.io/tags/CSS3/"/>
    
      <category term="BFC" scheme="https://xzh97.github.io/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>CSS总结</title>
    <link href="https://xzh97.github.io/2019/12/15/css-summary/"/>
    <id>https://xzh97.github.io/2019/12/15/css-summary/</id>
    <published>2019-12-15T13:35:25.000Z</published>
    <updated>2020-01-09T14:30:42.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>在前几天的面试题中，碰到了一些css的问题。发现自己虽然可以答出大部分的东西，但是还是有一些不太常见的地方说的不准确。</p><h2 id="CSS"><a class="header-anchor" href="#CSS"></a>CSS</h2><p>CSS就是指层叠样式表(Cascading Style Sheets)，主要是用来定义如何显示HTML文档。是页面更加好看，美观。</p><h2 id="选择器"><a class="header-anchor" href="#选择器"></a>选择器</h2><p>选择器就是用来通过某些条件来选择与CSS规则相匹配的HTML元素。<br>选择器主要有以下这些</p><ul><li>通配符（*）：通配符会匹配HTML文档的所有元素</li><li>元素选择器：例：<code>body{}</code>选择HTML文档中的<code>body</code>元素</li><li>类选择器：例：<code>.wrapper{}</code>选择HTML文档中<code>class</code>属性为<code>wrapper</code>的元素</li><li>id选择器：例：<code>#root</code>选择HTML文档中<code>id</code>属性为<code>root</code>的元素</li><li>后代选择器：例：<code>body .wrapper{}</code>选择<code>body</code>元素中的子元素类名为<code>wrapper</code>的元素</li><li>相邻元素选择器：例：<code>div + p{}</code>与<code>div</code>相邻的<code>p</code>元素（ps：<code>div</code>和<code>p</code>有同一个父级）</li><li>属性选择器：例：<code>input[type='text']{}</code>选择<code>input</code>中<code>type</code>为<code>text</code>的元素</li><li>伪类选择器：例：<code>div:hover{ cursor:'pointer'}</code>会在鼠标滑过<code>div</code>时把鼠标变成一个小手</li></ul><h2 id="优先级"><a class="header-anchor" href="#优先级"></a>优先级</h2><p>对于选择器来说，是会有优先级的。主要指浏览器通过优先级来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。<br><strong>优先级的计算方式：!important &gt; 内联 &gt; id选择器(#) &gt; 类选择器(.) &gt; 元素选择器</strong></p><h2 id="继承"><a class="header-anchor" href="#继承"></a>继承</h2><p>html元素可以从父元素那里继承一部分css属性，即使当前元素没有定义该属性。这样可以少重复定义很多的属性。</p><ul><li>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</li><li>所有元素可继承：visibility和cursor。</li><li>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</li><li>终端块状元素可继承：text-indent和text-align。</li><li>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。</li><li>表格元素可继承：border-collapse。</li></ul><h2 id="CSS3"><a class="header-anchor" href="#CSS3"></a>CSS3</h2><p>CSS3其实也没有什么很多东西，主要就是对于CSS的一些补充和加强。</p><ul><li>font-face 可以设置字体集</li><li>@media 媒体查询，可以设置元素在不同分辨率下的css</li><li>transform 对元素进行2d、3d转换实现对元素的移动、缩放、转动、拉长或拉伸。</li><li>transition 过渡 元素从一种样式逐渐改变为另一种的效果。</li><li>border-radius 边框圆角 是边框可以有圆角</li><li>box-shadow 边框阴影</li><li>box-sizing 盒子模型 设置width和height是否包括内边距（padding）和外边距（margin）<ul><li>border-box：设置的 width/height = width/height + margin + padding</li><li>content-box：设置的width/height = width/height</li></ul></li><li>animation，@keyframes 动画</li><li>flex 弹性布局模式 使布局更加舒服</li></ul><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>css虽然平时用起来其实并不难，可实际上还是有很多的知识点需要学习。毕竟世界不是一成不变的。很多时候都需要发展才能更好的满足开发需要。哦对了,这里强烈推荐<a href="https://www.zhangxinxu.com/" target="_blank" rel="noopener">张鑫旭</a>的博客网站。他对于css的理解真的非常深，网站有很多好文，看了让人受益良多。<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;在前几天的面试题中，碰到了一些css的问题。发现自己虽然可以答出大部分的东西，但是还是有一些不太常见的地方说的不准确。&lt;/p&gt;
&lt;h2 id=&quot;CSS&quot;&gt;
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://xzh97.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://xzh97.github.io/tags/CSS/"/>
    
      <category term="CSS3" scheme="https://xzh97.github.io/tags/CSS3/"/>
    
      <category term="选择器" scheme="https://xzh97.github.io/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
      <category term="优先级" scheme="https://xzh97.github.io/tags/%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
      <category term="CSS继承" scheme="https://xzh97.github.io/tags/CSS%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>web端的离线存储方式</title>
    <link href="https://xzh97.github.io/2019/12/15/offline-storage/"/>
    <id>https://xzh97.github.io/2019/12/15/offline-storage/</id>
    <published>2019-12-15T10:02:35.000Z</published>
    <updated>2020-01-09T14:30:42.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>昨天在学习的时候，看的问题里问HTML5的文件离线储存怎么使用，工作原理是什么？ 离线存储方式其实大概知道有这么些方式，还用过其中一些。但是要问原理的话其实还真的平时没去了解过。<br>所以今天来学习一下web端的几种离线存储方式。以后在项目里也可以尝试去使用这些特性。</p><h2 id="离线存储有以下几种方式"><a class="header-anchor" href="#离线存储有以下几种方式"></a>离线存储有以下几种方式</h2><ul><li>Application Cache</li><li>localStorage</li><li>sessionStorage</li><li>cookie</li><li>webSQL</li><li>indexedDB</li></ul><h2 id="Application-Cache"><a class="header-anchor" href="#Application-Cache"></a>Application Cache</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">Application Cache</a>目前已经被web标准废弃。这里不多讲，有兴趣的自行去了解一下吧。</p><h2 id="localStorage，sessionStorage（以下统称为storage）"><a class="header-anchor" href="#localStorage，sessionStorage（以下统称为storage）"></a>localStorage，sessionStorage（以下统称为storage）</h2><p><code>storage</code>都是H5新增的离线储存方式。<br><strong>浏览器兼容性：</strong><code>IE8+，Chrome，Firefox，Safari，Opera</code><br>**存储方式：**它们会以键值对的形式存储数据（需注意的是，存储的数据必须是字符串格式）<br><strong>优点</strong></p><ul><li>存储量大</li><li>浏览器原生支持</li><li>api简洁，使用方便</li><li>不需要和服务器交互</li></ul><p><strong>缺点</strong></p><ul><li>仍然会有浏览器兼容问题</li><li>安全性不是很好（别存敏感数据）</li></ul><p><strong>localStorage和sessionStorage的差别</strong></p><ul><li><code>localStorage</code>存储在浏览器本地，不会过期</li><li><code>sessionStorage</code>一旦当前页面会话关闭，数据就会删除</li></ul><p><strong>如何使用</strong></p><ul><li>存储：<code>storage.setItem(key,value)</code></li><li>获取：<code>storage.getItem(key,value)</code></li><li>删除：<code>storage.removeItem(key,value)</code>，当然啦 还可以按<code>F12</code>手动删除</li><li>删除所有：<code>storage.clear()</code></li></ul><h2 id="Cookie"><a class="header-anchor" href="#Cookie"></a>Cookie</h2><p>cookie是由后端服务器端创建保存在客服端一种数据库结构。浏览器请求和后端服务端响应都会携带创建的cookie来回传输。cookie在传输时存储在请求头和响应头中。<br>**原理：**客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。<br>**版本：**cookie有两个版本：version0和version1，它们两种设置响应头的标识，分别是“Set-Cookie”和“Set-Cookie2”。这两个版本的属性项有些不同。但是version1已经被废弃了。<br><strong>优点</strong></p><ul><li>拓展性和可用性都很好</li><li>不需要耗费服务器资源</li><li>简单</li><li>cookie生命周期可控</li></ul><p><strong>缺点</strong></p><ul><li>cookie数量和长度都有限制<ul><li>ie6及以下最多<strong>20</strong>个</li><li>ie7+，Firefox可以有<strong>50</strong>个</li><li>chrome和Safari没有限制</li><li>cookie的长度最多<strong>4k</strong>,大于4k会被截掉</li></ul></li><li>安全性：cookie有被截取篡改的风险</li><li>耗费资源：无论需不需要，都会加上cookie。</li></ul><p><strong>如何使用</strong><br>*添加<br>获取客户端的Cookie时，只能获取name与value属性，其它属性都不会被提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>,<span class="string">"xzh"</span>);<span class="comment">// 新建一个Cookie对象</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);                    <span class="comment">// 设置过期时间1天，以秒为单位</span></span><br><span class="line">response.addCookie(cookie);                    <span class="comment">// 保存cookie到客户端&#123;username:'xzh'&#125;</span></span><br></pre></td></tr></table></figure><p>*修改<br>只需要新建一个只有value不一样的同名cookie，然后添加到response中就可以覆盖掉原来的cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>,<span class="string">"xzh1"</span>);<span class="comment">// 新建一个Cookie对象</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);                    <span class="comment">// 设置过期时间1天，以秒为单位</span></span><br><span class="line">response.addCookie(cookie);                    <span class="comment">// 执行后就覆盖了原来的cookie&#123;username:'xzh1'&#125;</span></span><br></pre></td></tr></table></figure><p>*删除<br>只需要新建一个maxAge和value不一样的同名cookie，然后添加到response中就可以覆盖掉原来的cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>,<span class="string">"xzh"</span>);<span class="comment">// 新建一个Cookie对象</span></span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);                    <span class="comment">// 设置为0表示要删除</span></span><br><span class="line">response.addCookie(cookie);                    <span class="comment">// 执行后就从response里删除了</span></span><br></pre></td></tr></table></figure><h2 id="WebSQL"><a class="header-anchor" href="#WebSQL"></a>WebSQL</h2><p><a href="https://www.runoob.com/html/html5-web-sql.html" target="_blank" rel="noopener">Web SQL</a> 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。<br>**浏览器兼容性：**Web SQL 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。<br><strong>核心方法</strong><br>以下是规范中定义的三个核心方法：</p><ul><li>openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。</li><li>transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。</li><li>executeSql：这个方法用于执行实际的 SQL 查询。</li></ul><p><strong>优点</strong></p><ul><li>本地的SQL</li><li>可以处理复杂数据</li></ul><p><strong>缺点</strong></p><ul><li>兼容性太差（光是这个就足以判死刑了。。。）</li></ul><p><strong>如何使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@desc </span>openDatabase参数说明 ，，，，</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>databaseName 数据库名称</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>version 版本号</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>description 描述文本</span></span><br><span class="line"><span class="comment"><span class="doctag">@param </span>size 数据库大小</span></span><br><span class="line"><span class="comment"><span class="doctag">@param<span class="type">&#123;Function&#125;</span> </span>callback 创建回调</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//打开数据库</span></span><br><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建logs表，以及插入数据</span></span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'</span>);</span><br><span class="line">   tx.executeSql(<span class="string">'INSERT INTO LOGS (id, log) VALUES (1, "菜鸟教程")'</span>);</span><br><span class="line">   tx.executeSql(<span class="string">'INSERT INTO LOGS (id, log) VALUES (2, "www.runoob.com")'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">//查询记录</span></span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">'SELECT * FROM LOGS'</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">tx, results</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> len = results.rows.length, i;</span><br><span class="line">      msg = <span class="string">"&lt;p&gt;查询记录条数: "</span> + len + <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">'#status'</span>).innerHTML +=  msg;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">         alert(results.rows.item(i).log );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="IndexedDB"><a class="header-anchor" href="#IndexedDB"></a>IndexedDB</h2><p>用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索<br><strong>优点</strong></p><ul><li>标准化</li><li>存储复杂数据</li><li>支持索引</li></ul><p><strong>缺点</strong></p><ul><li>操作复杂</li><li>只适用于复杂数据（其实也是因为上一条 操作比较复杂，存储简单数据可以用但是没必要。）</li></ul><p><strong>如何使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开数据库，第一个参数为数据库名，第二个为数据库版本号</span></span><br><span class="line"><span class="keyword">var</span> dbRequest = <span class="built_in">window</span>.indexedDB.open(<span class="string">'testDb'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">dbRequest.onupgradeneeded=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建数据仓库</span></span><br><span class="line">    <span class="keyword">var</span> db=e.target.result;</span><br><span class="line">    <span class="keyword">if</span>(!db.objectStoreNames.contains(<span class="string">'users'</span>))&#123;</span><br><span class="line">        <span class="keyword">var</span> store=db.createObjectStore(<span class="string">'users'</span>,&#123;<span class="attr">keyPath</span>: <span class="string">'id'</span>&#125;);</span><br><span class="line">        store.createIndex(<span class="string">'nameIndex'</span>,<span class="string">'name'</span>,&#123;<span class="attr">unique</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        store.createIndex(<span class="string">'ageIndex'</span>,<span class="string">'age'</span>,&#123;<span class="attr">unique</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'upgrade successfully!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dbRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Open database successfully!'</span>);</span><br><span class="line">  <span class="comment">// 这里拿到了数据库</span></span><br><span class="line">  <span class="keyword">var</span> db = e.target.result;</span><br><span class="line">  <span class="keyword">var</span> storeName = <span class="string">'users'</span>;</span><br><span class="line">  <span class="comment">// 写入数据</span></span><br><span class="line">  <span class="keyword">var</span> tran = db.transaction(storeName, <span class="string">'readwrite'</span>);</span><br><span class="line">  <span class="keyword">var</span> users = tran.objectStore(storeName);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    users.add(&#123;</span><br><span class="line">      id: i,</span><br><span class="line">      name: <span class="string">'user'</span> + i,</span><br><span class="line">      age: <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">18</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询数据</span></span><br><span class="line">  <span class="keyword">var</span> userStore = db.transaction(storeName).objectStore(storeName);</span><br><span class="line">  <span class="keyword">var</span> request = userStore.openCursor();</span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cursor = e.target.result;</span><br><span class="line">    <span class="keyword">if</span>(cursor)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(cursor.key);</span><br><span class="line">      <span class="built_in">console</span>.log(cursor.value);</span><br><span class="line">      cursor.continue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>总之，前端用的最多的其实还是storage和cookie。 webSQL和indexedDB目前来说应用场景都比较少。所以后面两个只是大致了解了一下。 有兴趣的话，可以自己去mdn看看。说不定哪天也许就用到了。<br>That’s all! Thanks for watching!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;昨天在学习的时候，看的问题里问HTML5的文件离线储存怎么使用，工作原理是什么？ 离线存储方式其实大概知道有这么些方式，还用过其中一些。但是要问原理的话其
      
    
    </summary>
    
    
      <category term="HTML5" scheme="https://xzh97.github.io/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="https://xzh97.github.io/tags/HTML5/"/>
    
      <category term="cache" scheme="https://xzh97.github.io/tags/cache/"/>
    
      <category term="web" scheme="https://xzh97.github.io/tags/web/"/>
    
      <category term="离线存储" scheme="https://xzh97.github.io/tags/%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>介绍</title>
    <link href="https://xzh97.github.io/2019/12/15/introduction/"/>
    <id>https://xzh97.github.io/2019/12/15/introduction/</id>
    <published>2019-12-15T03:07:44.000Z</published>
    <updated>2020-01-09T14:30:42.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要做博客？"><a class="header-anchor" href="#为什么要做博客？"></a>为什么要做博客？</h2><p>弄个博客其实更多的是想让自己有一个独立的空间吧。算是个自己的狭小空间？这么说感觉有点中二诶。但主要意思到了应该就行。<br>主要还是用来记录自己的学习总结、工作总结。😄</p><h2 id="为什么转用hexo加github来做博客？"><a class="header-anchor" href="#为什么转用hexo加github来做博客？"></a>为什么转用hexo加github来做博客？</h2><p>其实在此之前，我自己已经弄了一个博客项目了。 并且已经部署到服务器上。<a href="http://122.51.73.210" target="_blank" rel="noopener">点击此处可查看</a></p><p>but！最后还是败给了设计上， 实在是受不了自己的设计水平。包括但不限于前端页面设计（ps：对，还有后端和数据库的设计，我吐了）<br>然后，在偶然的一天。看到了<a href="https://imjad.cn/" target="_blank" rel="noopener">journey.ad</a>的个人网站。看到了他迁移到了<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>，于是有点好奇的点开了。然后进入了<br>hexo的大门。</p><p>当然，作为一个铁骨铮铮的硬汉。哪怕猝死，死外边，从这跳下去。不会用你hexo一点东西。 对⑧起，真香。<br>然后，这两天好好看了一下hexo，觉得还是挺好用的吧。因为hexo的文章是自己可以直接用markdown写。于之后的保存，编辑都很方便。再加上又可以用github直接看。<br>而且因为要弄个人网站（备案感觉好麻烦qaq，要备案的话，得办居住证，得半年才能下来。又得办居住证啥的，又得各种跑。感觉挺麻烦的）<br>于是慎重考虑之后，最终选择了hexo。当然之前的blog项目并没有下掉。 虽然可能之后不会作为文章的发布的地方，但是作为一个练习用的项目还是挺好的。学习的时候自己去慢慢实践啥的也挺好。<br><strong>学习的话是要持续不断的。我这里主要总结的内容会来自于github的<a href="https://github.com/haizlin/fe-interview" target="_blank" rel="noopener">fe-interview</a>，希望自己能跟上脚步，每天都能学习一些东西</strong><br><strong>至于发布频率的话，我尽量保持一天一篇吧。 但也不能完全保证，有时候加班比较忙的话，就不一定有时间写了。</strong></p><p>That’s all!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要做博客？&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#为什么要做博客？&quot;&gt;&lt;/a&gt;为什么要做博客？&lt;/h2&gt;
&lt;p&gt;弄个博客其实更多的是想让自己有一个独立的空间吧。算是个自己的狭小空间？这么说感觉有点中二诶。但主要意思到了应该就行。&lt;
      
    
    </summary>
    
    
    
      <category term="intro" scheme="https://xzh97.github.io/tags/intro/"/>
    
      <category term="xzh" scheme="https://xzh97.github.io/tags/xzh/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xzh97.github.io/2019/12/14/hello-world/"/>
    <id>https://xzh97.github.io/2019/12/14/hello-world/</id>
    <published>2019-12-14T08:08:49.846Z</published>
    <updated>2019-12-14T08:08:49.846Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
